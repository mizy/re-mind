(self["webpackChunk_tntx_remind"] = self["webpackChunk_tntx_remind"] || []).push([["vendors-node_modules_antd_lib_back-top_i"],{

/***/ "./node_modules/antd/lib/back-top/index.js":
/*!*************************************************!*\
  !*** ./node_modules/antd/lib/back-top/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js"));

var React = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _rcMotion = _interopRequireDefault(__webpack_require__(/*! rc-motion */ "./node_modules/rc-motion/es/index.js"));

var _addEventListener = _interopRequireDefault(__webpack_require__(/*! rc-util/lib/Dom/addEventListener */ "./node_modules/rc-util/lib/Dom/addEventListener.js"));

var _useMergedState3 = _interopRequireDefault(__webpack_require__(/*! rc-util/lib/hooks/useMergedState */ "./node_modules/rc-util/lib/hooks/useMergedState.js"));

var _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ "./node_modules/classnames/index.js"));

var _omit = _interopRequireDefault(__webpack_require__(/*! rc-util/lib/omit */ "./node_modules/rc-util/lib/omit.js"));

var _VerticalAlignTopOutlined = _interopRequireDefault(__webpack_require__(/*! @ant-design/icons/VerticalAlignTopOutlined */ "./node_modules/@ant-design/icons/VerticalAlignTopOutlined.js"));

var _throttleByAnimationFrame = __webpack_require__(/*! ../_util/throttleByAnimationFrame */ "./node_modules/antd/lib/_util/throttleByAnimationFrame.js");

var _configProvider = __webpack_require__(/*! ../config-provider */ "./node_modules/antd/lib/config-provider/index.js");

var _getScroll = _interopRequireDefault(__webpack_require__(/*! ../_util/getScroll */ "./node_modules/antd/lib/_util/getScroll.js"));

var _scrollTo = _interopRequireDefault(__webpack_require__(/*! ../_util/scrollTo */ "./node_modules/antd/lib/_util/scrollTo.js"));

var _reactNode = __webpack_require__(/*! ../_util/reactNode */ "./node_modules/antd/lib/_util/reactNode.js");

var BackTop = function BackTop(props) {
  var _useMergedState = (0, _useMergedState3["default"])(false, {
    value: props.visible
  }),
      _useMergedState2 = (0, _slicedToArray2["default"])(_useMergedState, 2),
      visible = _useMergedState2[0],
      setVisible = _useMergedState2[1];

  var ref = /*#__PURE__*/React.createRef();
  var scrollEvent = React.useRef();

  var getDefaultTarget = function getDefaultTarget() {
    return ref.current && ref.current.ownerDocument ? ref.current.ownerDocument : window;
  };

  var handleScroll = (0, _throttleByAnimationFrame.throttleByAnimationFrame)(function (e) {
    var visibilityHeight = props.visibilityHeight;
    var scrollTop = (0, _getScroll["default"])(e.target, true);
    setVisible(scrollTop > visibilityHeight);
  });

  var bindScrollEvent = function bindScrollEvent() {
    var target = props.target;
    var getTarget = target || getDefaultTarget;
    var container = getTarget();
    scrollEvent.current = (0, _addEventListener["default"])(container, 'scroll', function (e) {
      handleScroll(e);
    });
    handleScroll({
      target: container
    });
  };

  React.useEffect(function () {
    bindScrollEvent();
    return function () {
      if (scrollEvent.current) {
        scrollEvent.current.remove();
      }

      handleScroll.cancel();
    };
  }, [props.target]);

  var scrollToTop = function scrollToTop(e) {
    var onClick = props.onClick,
        target = props.target,
        _props$duration = props.duration,
        duration = _props$duration === void 0 ? 450 : _props$duration;
    (0, _scrollTo["default"])(0, {
      getContainer: target || getDefaultTarget,
      duration: duration
    });

    if (typeof onClick === 'function') {
      onClick(e);
    }
  };

  var renderChildren = function renderChildren(_ref) {
    var prefixCls = _ref.prefixCls,
        rootPrefixCls = _ref.rootPrefixCls;
    var children = props.children;
    var defaultElement = /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, /*#__PURE__*/React.createElement("div", {
      className: "".concat(prefixCls, "-icon")
    }, /*#__PURE__*/React.createElement(_VerticalAlignTopOutlined["default"], null)));
    return /*#__PURE__*/React.createElement(_rcMotion["default"], {
      visible: visible,
      motionName: "".concat(rootPrefixCls, "-fade"),
      removeOnLeave: true
    }, function (_ref2) {
      var motionClassName = _ref2.className;
      var childNode = children || defaultElement;
      return /*#__PURE__*/React.createElement("div", null, (0, _reactNode.cloneElement)(childNode, function (_ref3) {
        var className = _ref3.className;
        return {
          className: (0, _classnames["default"])(motionClassName, className)
        };
      }));
    });
  };

  var _React$useContext = React.useContext(_configProvider.ConfigContext),
      getPrefixCls = _React$useContext.getPrefixCls,
      direction = _React$useContext.direction;

  var customizePrefixCls = props.prefixCls,
      _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className;
  var prefixCls = getPrefixCls('back-top', customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var classString = (0, _classnames["default"])(prefixCls, (0, _defineProperty2["default"])({}, "".concat(prefixCls, "-rtl"), direction === 'rtl'), className); // fix https://fb.me/react-unknown-prop

  var divProps = (0, _omit["default"])(props, ['prefixCls', 'className', 'children', 'visibilityHeight', 'target', 'visible']);
  return /*#__PURE__*/React.createElement("div", (0, _extends2["default"])({}, divProps, {
    className: classString,
    onClick: scrollToTop,
    ref: ref
  }), renderChildren({
    prefixCls: prefixCls,
    rootPrefixCls: rootPrefixCls
  }));
};

BackTop.defaultProps = {
  visibilityHeight: 400
};

var _default = /*#__PURE__*/React.memo(BackTop);

exports.default = _default;

/***/ }),

/***/ "./node_modules/antd/lib/back-top/style/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/antd/lib/back-top/style/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ../../style/index.less */ "./node_modules/antd/lib/style/index.less");

__webpack_require__(/*! ./index.less */ "./node_modules/antd/lib/back-top/style/index.less");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/antd/lib/back-top/style/index.less":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/antd/lib/back-top/style/index.less ***!
  \******************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* stylelint-disable at-rule-empty-line-before,at-rule-name-space-after,at-rule-no-unknown */\n/* stylelint-disable no-duplicate-selectors */\n/* stylelint-disable */\n/* stylelint-disable declaration-bang-space-before,no-duplicate-selectors,string-no-newline */\n.ant-back-top {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  color: rgba(0, 0, 0, 0.85);\n  font-size: 14px;\n  font-variant: tabular-nums;\n  line-height: 1.5715;\n  list-style: none;\n  font-feature-settings: 'tnum';\n  position: fixed;\n  right: 100px;\n  bottom: 50px;\n  z-index: 10;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n}\n.ant-back-top:empty {\n  display: none;\n}\n.ant-back-top-rtl {\n  right: auto;\n  left: 100px;\n  direction: rtl;\n}\n.ant-back-top-content {\n  width: 40px;\n  height: 40px;\n  overflow: hidden;\n  color: #fff;\n  text-align: center;\n  background-color: rgba(0, 0, 0, 0.45);\n  border-radius: 20px;\n  transition: all 0.3s;\n}\n.ant-back-top-content:hover {\n  background-color: rgba(0, 0, 0, 0.85);\n  transition: all 0.3s;\n}\n.ant-back-top-icon {\n  font-size: 24px;\n  line-height: 40px;\n}\n@media screen and (max-width: 768px) {\n  .ant-back-top {\n    right: 60px;\n  }\n}\n@media screen and (max-width: 480px) {\n  .ant-back-top {\n    right: 20px;\n  }\n}\n", "",{"version":3,"sources":["webpack://./node_modules/antd/lib/back-top/style/index.less","webpack://./node_modules/antd/lib/style/color/tinyColor.less","webpack://./node_modules/antd/lib/style/mixins/reset.less","webpack://./node_modules/antd/lib/back-top/style/responsive.less"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,6CAA6C;AAC7C,sBAAsB;AACtB,6FAA6F;ACH5F;ECGC,sBAAA;EACA,SAAA;EACA,UAAA;EACA,0BAAA;EACA,eAAA;EACA,0BAAA;EACA,mBAAA;EACA,gBAAA;EACA,6BAAA;EFHA,eAAA;EACA,YAAA;EACA,YAAA;EACA,WAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;AAOF;AALE;EACE,aAAA;AAOJ;AAJE;EACE,WAAA;EACA,WAAA;EACA,cAAA;AAMJ;AAHE;EACE,WAAA;EACA,YAAA;EACA,gBAAA;EACA,WAAA;EACA,kBAAA;EACA,qCAAA;EACA,mBAAA;EACA,oBAAA;AAKJ;AAHI;EACE,qCAAA;EACA,oBAAA;AAKN;AADE;EACE,eAAA;EACA,iBAAA;AAGJ;AG/CA;EFAC;IEEG,WAAA;EHiDF;AACF;AG9CA;EFNC;IEQG,WAAA;EHgDF;AACF","sourcesContent":["@import '../../style/themes/index';\n@import '../../style/mixins/index';\n\n@backtop-prefix-cls: ~'@{ant-prefix}-back-top';\n\n.@{backtop-prefix-cls} {\n  .reset-component();\n\n  position: fixed;\n  right: 100px;\n  bottom: 50px;\n  z-index: @zindex-back-top;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n\n  &:empty {\n    display: none;\n  }\n\n  &-rtl {\n    right: auto;\n    left: 100px;\n    direction: rtl;\n  }\n\n  &-content {\n    width: 40px;\n    height: 40px;\n    overflow: hidden;\n    color: @back-top-color;\n    text-align: center;\n    background-color: @back-top-bg;\n    border-radius: 20px;\n    transition: all 0.3s;\n\n    &:hover {\n      background-color: @back-top-hover-bg;\n      transition: all 0.3s;\n    }\n  }\n\n  &-icon {\n    font-size: 24px;\n    line-height: 40px;\n  }\n}\n\n@import './responsive';\n","/* stylelint-disable declaration-bang-space-before,no-duplicate-selectors,string-no-newline */\n.tinyColorMixin() {\n@functions: ~`(function() {\n// TinyColor v1.4.1\n// https://github.com/bgrins/TinyColor\n// 2016-07-07, Brian Grinstead, MIT License\nvar trimLeft = /^\\s+/,\n    trimRight = /\\s+$/,\n    tinyCounter = 0,\n    mathRound = Math.round,\n    mathMin = Math.min,\n    mathMax = Math.max,\n    mathRandom = Math.random;\n\nfunction tinycolor (color, opts) {\n\n    color = (color) ? color : '';\n    opts = opts || { };\n\n    // If input is already a tinycolor, return itself\n    if (color instanceof tinycolor) {\n       return color;\n    }\n    // If we are called as a function, call using new instead\n    if (!(this instanceof tinycolor)) {\n        return new tinycolor(color, opts);\n    }\n\n    var rgb = inputToRGB(color);\n    this._originalInput = color,\n    this._r = rgb.r,\n    this._g = rgb.g,\n    this._b = rgb.b,\n    this._a = rgb.a,\n    this._roundA = mathRound(100*this._a) / 100,\n    this._format = opts.format || rgb.format;\n    this._gradientType = opts.gradientType;\n\n    // Don't let the range of [0,255] come back in [0,1].\n    // Potentially lose a little bit of precision here, but will fix issues where\n    // .5 gets interpreted as half of the total, instead of half of 1\n    // If it was supposed to be 128, this was already taken care of by inputToRgb\n    if (this._r < 1) { this._r = mathRound(this._r); }\n    if (this._g < 1) { this._g = mathRound(this._g); }\n    if (this._b < 1) { this._b = mathRound(this._b); }\n\n    this._ok = rgb.ok;\n    this._tc_id = tinyCounter++;\n}\n\ntinycolor.prototype = {\n    isDark: function() {\n        return this.getBrightness() < 128;\n    },\n    isLight: function() {\n        return !this.isDark();\n    },\n    isValid: function() {\n        return this._ok;\n    },\n    getOriginalInput: function() {\n      return this._originalInput;\n    },\n    getFormat: function() {\n        return this._format;\n    },\n    getAlpha: function() {\n        return this._a;\n    },\n    getBrightness: function() {\n        //http://www.w3.org/TR/AERT#color-contrast\n        var rgb = this.toRgb();\n        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n    },\n    getLuminance: function() {\n        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        var rgb = this.toRgb();\n        var RsRGB, GsRGB, BsRGB, R, G, B;\n        RsRGB = rgb.r/255;\n        GsRGB = rgb.g/255;\n        BsRGB = rgb.b/255;\n\n        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}\n        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}\n        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}\n        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);\n    },\n    setAlpha: function(value) {\n        this._a = boundAlpha(value);\n        this._roundA = mathRound(100*this._a) / 100;\n        return this;\n    },\n    toHsv: function() {\n        var hsv = rgbToHsv(this._r, this._g, this._b);\n        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };\n    },\n    toHsvString: function() {\n        var hsv = rgbToHsv(this._r, this._g, this._b);\n        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);\n        return (this._a == 1) ?\n          \"hsv(\"  + h + \", \" + s + \"%, \" + v + \"%)\" :\n          \"hsva(\" + h + \", \" + s + \"%, \" + v + \"%, \"+ this._roundA + \")\";\n    },\n    toHsl: function() {\n        var hsl = rgbToHsl(this._r, this._g, this._b);\n        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };\n    },\n    toHslString: function() {\n        var hsl = rgbToHsl(this._r, this._g, this._b);\n        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);\n        return (this._a == 1) ?\n          \"hsl(\"  + h + \", \" + s + \"%, \" + l + \"%)\" :\n          \"hsla(\" + h + \", \" + s + \"%, \" + l + \"%, \"+ this._roundA + \")\";\n    },\n    toHex: function(allow3Char) {\n        return rgbToHex(this._r, this._g, this._b, allow3Char);\n    },\n    toHexString: function(allow3Char) {\n        return '#' + this.toHex(allow3Char);\n    },\n    toHex8: function(allow4Char) {\n        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);\n    },\n    toHex8String: function(allow4Char) {\n        return '#' + this.toHex8(allow4Char);\n    },\n    toRgb: function() {\n        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };\n    },\n    toRgbString: function() {\n        return (this._a == 1) ?\n          \"rgb(\"  + mathRound(this._r) + \", \" + mathRound(this._g) + \", \" + mathRound(this._b) + \")\" :\n          \"rgba(\" + mathRound(this._r) + \", \" + mathRound(this._g) + \", \" + mathRound(this._b) + \", \" + this._roundA + \")\";\n    },\n    toPercentageRgb: function() {\n        return { r: mathRound(bound01(this._r, 255) * 100) + \"%\", g: mathRound(bound01(this._g, 255) * 100) + \"%\", b: mathRound(bound01(this._b, 255) * 100) + \"%\", a: this._a };\n    },\n    toPercentageRgbString: function() {\n        return (this._a == 1) ?\n          \"rgb(\"  + mathRound(bound01(this._r, 255) * 100) + \"%, \" + mathRound(bound01(this._g, 255) * 100) + \"%, \" + mathRound(bound01(this._b, 255) * 100) + \"%)\" :\n          \"rgba(\" + mathRound(bound01(this._r, 255) * 100) + \"%, \" + mathRound(bound01(this._g, 255) * 100) + \"%, \" + mathRound(bound01(this._b, 255) * 100) + \"%, \" + this._roundA + \")\";\n    },\n    toName: function() {\n        if (this._a === 0) {\n            return \"transparent\";\n        }\n\n        if (this._a < 1) {\n            return false;\n        }\n\n        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n    },\n    toFilter: function(secondColor) {\n        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);\n        var secondHex8String = hex8String;\n        var gradientType = this._gradientType ? \"GradientType = 1, \" : \"\";\n\n        if (secondColor) {\n            var s = tinycolor(secondColor);\n            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);\n        }\n\n        return \"progid:DXImageTransform.Microsoft.gradient(\"+gradientType+\"startColorstr=\"+hex8String+\",endColorstr=\"+secondHex8String+\")\";\n    },\n    toString: function(format) {\n        var formatSet = !!format;\n        format = format || this._format;\n\n        var formattedString = false;\n        var hasAlpha = this._a < 1 && this._a >= 0;\n        var needsAlphaFormat = !formatSet && hasAlpha && (format === \"hex\" || format === \"hex6\" || format === \"hex3\" || format === \"hex4\" || format === \"hex8\" || format === \"name\");\n\n        if (needsAlphaFormat) {\n            // Special case for \"transparent\", all other non-alpha formats\n            // will return rgba when there is transparency.\n            if (format === \"name\" && this._a === 0) {\n                return this.toName();\n            }\n            return this.toRgbString();\n        }\n        if (format === \"rgb\") {\n            formattedString = this.toRgbString();\n        }\n        if (format === \"prgb\") {\n            formattedString = this.toPercentageRgbString();\n        }\n        if (format === \"hex\" || format === \"hex6\") {\n            formattedString = this.toHexString();\n        }\n        if (format === \"hex3\") {\n            formattedString = this.toHexString(true);\n        }\n        if (format === \"hex4\") {\n            formattedString = this.toHex8String(true);\n        }\n        if (format === \"hex8\") {\n            formattedString = this.toHex8String();\n        }\n        if (format === \"name\") {\n            formattedString = this.toName();\n        }\n        if (format === \"hsl\") {\n            formattedString = this.toHslString();\n        }\n        if (format === \"hsv\") {\n            formattedString = this.toHsvString();\n        }\n\n        return formattedString || this.toHexString();\n    },\n    clone: function() {\n        return tinycolor(this.toString());\n    },\n\n    _applyModification: function(fn, args) {\n        var color = fn.apply(null, [this].concat([].slice.call(args)));\n        this._r = color._r;\n        this._g = color._g;\n        this._b = color._b;\n        this.setAlpha(color._a);\n        return this;\n    },\n    lighten: function() {\n        return this._applyModification(lighten, arguments);\n    },\n    brighten: function() {\n        return this._applyModification(brighten, arguments);\n    },\n    darken: function() {\n        return this._applyModification(darken, arguments);\n    },\n    desaturate: function() {\n        return this._applyModification(desaturate, arguments);\n    },\n    saturate: function() {\n        return this._applyModification(saturate, arguments);\n    },\n    greyscale: function() {\n        return this._applyModification(greyscale, arguments);\n    },\n    spin: function() {\n        return this._applyModification(spin, arguments);\n    },\n\n    _applyCombination: function(fn, args) {\n        return fn.apply(null, [this].concat([].slice.call(args)));\n    },\n    analogous: function() {\n        return this._applyCombination(analogous, arguments);\n    },\n    complement: function() {\n        return this._applyCombination(complement, arguments);\n    },\n    monochromatic: function() {\n        return this._applyCombination(monochromatic, arguments);\n    },\n    splitcomplement: function() {\n        return this._applyCombination(splitcomplement, arguments);\n    },\n    triad: function() {\n        return this._applyCombination(triad, arguments);\n    },\n    tetrad: function() {\n        return this._applyCombination(tetrad, arguments);\n    }\n};\n\n// If input is an object, force 1 into \"1.0\" to handle ratios properly\n// String input requires \"1.0\" as input, so 1 will be treated as 1\ntinycolor.fromRatio = function(color, opts) {\n    if (typeof color == \"object\") {\n        var newColor = {};\n        for (var i in color) {\n            if (color.hasOwnProperty(i)) {\n                if (i === \"a\") {\n                    newColor[i] = color[i];\n                }\n                else {\n                    newColor[i] = convertToPercentage(color[i]);\n                }\n            }\n        }\n        color = newColor;\n    }\n\n    return tinycolor(color, opts);\n};\n\n// Given a string or object, convert that input to RGB\n// Possible string inputs:\n//\n//     \"red\"\n//     \"#f00\" or \"f00\"\n//     \"#ff0000\" or \"ff0000\"\n//     \"#ff000000\" or \"ff000000\"\n//     \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n//     \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n//     \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n//     \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n//     \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n//     \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n//     \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n//\nfunction inputToRGB(color) {\n\n    var rgb = { r: 0, g: 0, b: 0 };\n    var a = 1;\n    var s = null;\n    var v = null;\n    var l = null;\n    var ok = false;\n    var format = false;\n\n    if (typeof color == \"string\") {\n        color = stringInputToObject(color);\n    }\n\n    if (typeof color == \"object\") {\n        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {\n            rgb = rgbToRgb(color.r, color.g, color.b);\n            ok = true;\n            format = String(color.r).substr(-1) === \"%\" ? \"prgb\" : \"rgb\";\n        }\n        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {\n            s = convertToPercentage(color.s);\n            v = convertToPercentage(color.v);\n            rgb = hsvToRgb(color.h, s, v);\n            ok = true;\n            format = \"hsv\";\n        }\n        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {\n            s = convertToPercentage(color.s);\n            l = convertToPercentage(color.l);\n            rgb = hslToRgb(color.h, s, l);\n            ok = true;\n            format = \"hsl\";\n        }\n\n        if (color.hasOwnProperty(\"a\")) {\n            a = color.a;\n        }\n    }\n\n    a = boundAlpha(a);\n\n    return {\n        ok: ok,\n        format: color.format || format,\n        r: mathMin(255, mathMax(rgb.r, 0)),\n        g: mathMin(255, mathMax(rgb.g, 0)),\n        b: mathMin(255, mathMax(rgb.b, 0)),\n        a: a\n    };\n}\n\n// Conversion Functions\n// --------------------\n\n// rgbToHsl, rgbToHsv, hslToRgb, hsvToRgb modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n\n// rgbToRgb\n// Handle bounds / percentage checking to conform to CSS color spec\n// <http://www.w3.org/TR/css3-color/>\n// *Assumes:* r, g, b in [0, 255] or [0, 1]\n// *Returns:* { r, g, b } in [0, 255]\nfunction rgbToRgb(r, g, b){\n    return {\n        r: bound01(r, 255) * 255,\n        g: bound01(g, 255) * 255,\n        b: bound01(b, 255) * 255\n    };\n}\n\n// rgbToHsl\n// Converts an RGB color value to HSL.\n// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n// *Returns:* { h, s, l } in [0,1]\nfunction rgbToHsl(r, g, b) {\n\n    r = bound01(r, 255);\n    g = bound01(g, 255);\n    b = bound01(b, 255);\n\n    var max = mathMax(r, g, b), min = mathMin(r, g, b);\n    var h, s, l = (max + min) / 2;\n\n    if(max == min) {\n        h = s = 0; // achromatic\n    }\n    else {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch(max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n\n        h /= 6;\n    }\n\n    return { h: h, s: s, l: l };\n}\n\n// hslToRgb\n// Converts an HSL color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hslToRgb(h, s, l) {\n    var r, g, b;\n\n    h = bound01(h, 360);\n    s = bound01(s, 100);\n    l = bound01(l, 100);\n\n    function hue2rgb(p, q, t) {\n        if(t < 0) t += 1;\n        if(t > 1) t -= 1;\n        if(t < 1/6) return p + (q - p) * 6 * t;\n        if(t < 1/2) return q;\n        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n        return p;\n    }\n\n    if(s === 0) {\n        r = g = b = l; // achromatic\n    }\n    else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1/3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1/3);\n    }\n\n    return { r: r * 255, g: g * 255, b: b * 255 };\n}\n\n// rgbToHsv\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nfunction rgbToHsv(r, g, b) {\n\n    r = bound01(r, 255);\n    g = bound01(g, 255);\n    b = bound01(b, 255);\n\n    var max = mathMax(r, g, b), min = mathMin(r, g, b);\n    var h, s, v = max;\n\n    var d = max - min;\n    s = max === 0 ? 0 : d / max;\n\n    if(max == min) {\n        h = 0; // achromatic\n    }\n    else {\n        switch(max) {\n            case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n            case g: h = (b - r) / d + 2; break;\n            case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n    }\n    return { h: h, s: s, v: v };\n}\n\n// hsvToRgb\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\n function hsvToRgb(h, s, v) {\n\n    h = bound01(h, 360) * 6;\n    s = bound01(s, 100);\n    v = bound01(v, 100);\n\n    var i = Math.floor(h),\n        f = h - i,\n        p = v * (1 - s),\n        q = v * (1 - f * s),\n        t = v * (1 - (1 - f) * s),\n        mod = i % 6,\n        r = [v, q, p, p, t, v][mod],\n        g = [t, v, v, q, p, p][mod],\n        b = [p, p, t, v, v, q][mod];\n\n    return { r: r * 255, g: g * 255, b: b * 255 };\n}\n\n// rgbToHex\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r, g, b, allow3Char) {\n\n    var hex = [\n        pad2(mathRound(r).toString(16)),\n        pad2(mathRound(g).toString(16)),\n        pad2(mathRound(b).toString(16))\n    ];\n\n    // Return a 3 character hex if possible\n    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {\n        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n    }\n\n    return hex.join(\"\");\n}\n\n// rgbaToHex\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r, g, b, a, allow4Char) {\n\n    var hex = [\n        pad2(mathRound(r).toString(16)),\n        pad2(mathRound(g).toString(16)),\n        pad2(mathRound(b).toString(16)),\n        pad2(convertDecimalToHex(a))\n    ];\n\n    // Return a 4 character hex if possible\n    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {\n        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n    }\n\n    return hex.join(\"\");\n}\n\n// rgbaToArgbHex\n// Converts an RGBA color to an ARGB Hex8 string\n// Rarely used, but required for \"toFilter()\"\nfunction rgbaToArgbHex(r, g, b, a) {\n\n    var hex = [\n        pad2(convertDecimalToHex(a)),\n        pad2(mathRound(r).toString(16)),\n        pad2(mathRound(g).toString(16)),\n        pad2(mathRound(b).toString(16))\n    ];\n\n    return hex.join(\"\");\n}\n\n// equals\n// Can be called with any tinycolor input\ntinycolor.equals = function (color1, color2) {\n    if (!color1 || !color2) { return false; }\n    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();\n};\n\ntinycolor.random = function() {\n    return tinycolor.fromRatio({\n        r: mathRandom(),\n        g: mathRandom(),\n        b: mathRandom()\n    });\n};\n\n// Modification Functions\n// ----------------------\n// Thanks to less.js for some of the basics here\n// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\n\nfunction desaturate(color, amount) {\n    amount = (amount === 0) ? 0 : (amount || 10);\n    var hsl = tinycolor(color).toHsl();\n    hsl.s -= amount / 100;\n    hsl.s = clamp01(hsl.s);\n    return tinycolor(hsl);\n}\n\nfunction saturate(color, amount) {\n    amount = (amount === 0) ? 0 : (amount || 10);\n    var hsl = tinycolor(color).toHsl();\n    hsl.s += amount / 100;\n    hsl.s = clamp01(hsl.s);\n    return tinycolor(hsl);\n}\n\nfunction greyscale(color) {\n    return tinycolor(color).desaturate(100);\n}\n\nfunction lighten (color, amount) {\n    amount = (amount === 0) ? 0 : (amount || 10);\n    var hsl = tinycolor(color).toHsl();\n    hsl.l += amount / 100;\n    hsl.l = clamp01(hsl.l);\n    return tinycolor(hsl);\n}\n\nfunction brighten(color, amount) {\n    amount = (amount === 0) ? 0 : (amount || 10);\n    var rgb = tinycolor(color).toRgb();\n    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));\n    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));\n    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));\n    return tinycolor(rgb);\n}\n\nfunction darken (color, amount) {\n    amount = (amount === 0) ? 0 : (amount || 10);\n    var hsl = tinycolor(color).toHsl();\n    hsl.l -= amount / 100;\n    hsl.l = clamp01(hsl.l);\n    return tinycolor(hsl);\n}\n\n// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n// Values outside of this range will be wrapped into this range.\nfunction spin(color, amount) {\n    var hsl = tinycolor(color).toHsl();\n    var hue = (hsl.h + amount) % 360;\n    hsl.h = hue < 0 ? 360 + hue : hue;\n    return tinycolor(hsl);\n}\n\n// Combination Functions\n// ---------------------\n// Thanks to jQuery xColor for some of the ideas behind these\n// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\n\nfunction complement(color) {\n    var hsl = tinycolor(color).toHsl();\n    hsl.h = (hsl.h + 180) % 360;\n    return tinycolor(hsl);\n}\n\nfunction triad(color) {\n    var hsl = tinycolor(color).toHsl();\n    var h = hsl.h;\n    return [\n        tinycolor(color),\n        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),\n        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })\n    ];\n}\n\nfunction tetrad(color) {\n    var hsl = tinycolor(color).toHsl();\n    var h = hsl.h;\n    return [\n        tinycolor(color),\n        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),\n        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),\n        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })\n    ];\n}\n\nfunction splitcomplement(color) {\n    var hsl = tinycolor(color).toHsl();\n    var h = hsl.h;\n    return [\n        tinycolor(color),\n        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),\n        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})\n    ];\n}\n\nfunction analogous(color, results, slices) {\n    results = results || 6;\n    slices = slices || 30;\n\n    var hsl = tinycolor(color).toHsl();\n    var part = 360 / slices;\n    var ret = [tinycolor(color)];\n\n    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {\n        hsl.h = (hsl.h + part) % 360;\n        ret.push(tinycolor(hsl));\n    }\n    return ret;\n}\n\nfunction monochromatic(color, results) {\n    results = results || 6;\n    var hsv = tinycolor(color).toHsv();\n    var h = hsv.h, s = hsv.s, v = hsv.v;\n    var ret = [];\n    var modification = 1 / results;\n\n    while (results--) {\n        ret.push(tinycolor({ h: h, s: s, v: v}));\n        v = (v + modification) % 1;\n    }\n\n    return ret;\n}\n\n// Utility Functions\n// ---------------------\n\ntinycolor.mix = function(color1, color2, amount) {\n    amount = (amount === 0) ? 0 : (amount || 50);\n\n    var rgb1 = tinycolor(color1).toRgb();\n    var rgb2 = tinycolor(color2).toRgb();\n\n    var p = amount / 100;\n\n    var rgba = {\n        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,\n        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,\n        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,\n        a: ((rgb2.a - rgb1.a) * p) + rgb1.a\n    };\n\n    return tinycolor(rgba);\n};\n\n// Readability Functions\n// ---------------------\n// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)\n\n// contrast\n// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)\ntinycolor.readability = function(color1, color2) {\n    var c1 = tinycolor(color1);\n    var c2 = tinycolor(color2);\n    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);\n};\n\n// isReadable\n// Ensure that foreground and background color combinations meet WCAG2 guidelines.\n// The third argument is an optional Object.\n//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';\n//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.\n// If the entire object is absent, isReadable defaults to {level:\"AA\",size:\"small\"}.\n\n// *Example*\n//    tinycolor.isReadable(\"#000\", \"#111\") => false\n//    tinycolor.isReadable(\"#000\", \"#111\",{level:\"AA\",size:\"large\"}) => false\ntinycolor.isReadable = function(color1, color2, wcag2) {\n    var readability = tinycolor.readability(color1, color2);\n    var wcag2Parms, out;\n\n    out = false;\n\n    wcag2Parms = validateWCAG2Parms(wcag2);\n    switch (wcag2Parms.level + wcag2Parms.size) {\n        case \"AAsmall\":\n        case \"AAAlarge\":\n            out = readability >= 4.5;\n            break;\n        case \"AAlarge\":\n            out = readability >= 3;\n            break;\n        case \"AAAsmall\":\n            out = readability >= 7;\n            break;\n    }\n    return out;\n\n};\n\n// mostReadable\n// Given a base color and a list of possible foreground or background\n// colors for that base, returns the most readable color.\n// Optionally returns Black or White if the most readable color is unreadable.\n// *Example*\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:false}).toHexString(); // \"#112255\"\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:true}).toHexString();  // \"#ffffff\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"large\"}).toHexString(); // \"#faf3f3\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"small\"}).toHexString(); // \"#ffffff\"\ntinycolor.mostReadable = function(baseColor, colorList, args) {\n    var bestColor = null;\n    var bestScore = 0;\n    var readability;\n    var includeFallbackColors, level, size ;\n    args = args || {};\n    includeFallbackColors = args.includeFallbackColors ;\n    level = args.level;\n    size = args.size;\n\n    for (var i= 0; i < colorList.length ; i++) {\n        readability = tinycolor.readability(baseColor, colorList[i]);\n        if (readability > bestScore) {\n            bestScore = readability;\n            bestColor = tinycolor(colorList[i]);\n        }\n    }\n\n    if (tinycolor.isReadable(baseColor, bestColor, {\"level\":level,\"size\":size}) || !includeFallbackColors) {\n        return bestColor;\n    }\n    else {\n        args.includeFallbackColors=false;\n        return tinycolor.mostReadable(baseColor,[\"#fff\", \"#000\"],args);\n    }\n};\n\n// Big List of Colors\n// ------------------\n// <http://www.w3.org/TR/css3-color/#svg-color>\nvar names = tinycolor.names = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"0ff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"00f\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    burntsienna: \"ea7e5d\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"0ff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"f0f\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"663399\",\n    red: \"f00\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\n\n// Make it easy to access colors via hexNames[hex]\nvar hexNames = tinycolor.hexNames = flip(names);\n\n// Utilities\n// ---------\n\n// { 'name1': 'val1' } becomes { 'val1': 'name1' }\nfunction flip(o) {\n    var flipped = { };\n    for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n            flipped[o[i]] = i;\n        }\n    }\n    return flipped;\n}\n\n// Return a valid alpha value [0,1] with all invalid values being set to 1\nfunction boundAlpha(a) {\n    a = parseFloat(a);\n\n    if (isNaN(a) || a < 0 || a > 1) {\n        a = 1;\n    }\n\n    return a;\n}\n\n// Take input from [0, n] and return it as [0, 1]\nfunction bound01(n, max) {\n    if (isOnePointZero(n)) { n = \"100%\"; }\n\n    var processPercent = isPercentage(n);\n    n = mathMin(max, mathMax(0, parseFloat(n)));\n\n    // Automatically convert percentage into number\n    if (processPercent) {\n        n = parseInt(n * max, 10) / 100;\n    }\n\n    // Handle floating point rounding errors\n    if ((Math.abs(n - max) < 0.000001)) {\n        return 1;\n    }\n\n    // Convert into [0, 1] range if it isn't already\n    return (n % max) / parseFloat(max);\n}\n\n// Force a number between 0 and 1\nfunction clamp01(val) {\n    return mathMin(1, mathMax(0, val));\n}\n\n// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val) {\n    return parseInt(val, 16);\n}\n\n// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nfunction isOnePointZero(n) {\n    return typeof n == \"string\" && n.indexOf('.') != -1 && parseFloat(n) === 1;\n}\n\n// Check to see if string passed in is a percentage\nfunction isPercentage(n) {\n    return typeof n === \"string\" && n.indexOf('%') != -1;\n}\n\n// Force a hex value to have 2 characters\nfunction pad2(c) {\n    return c.length == 1 ? '0' + c : '' + c;\n}\n\n// Replace a decimal with it's percentage value\nfunction convertToPercentage(n) {\n    if (n <= 1) {\n        n = (n * 100) + \"%\";\n    }\n\n    return n;\n}\n\n// Converts a decimal to a hex value\nfunction convertDecimalToHex(d) {\n    return Math.round(parseFloat(d) * 255).toString(16);\n}\n// Converts a hex value to a decimal\nfunction convertHexToDecimal(h) {\n    return (parseIntFromHex(h) / 255);\n}\n\nvar matchers = (function() {\n\n    // <http://www.w3.org/TR/css3-values/#integers>\n    var CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\n\n    // <http://www.w3.org/TR/css3-values/#number-value>\n    var CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n\n    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\n    var CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\n\n    // Actual matching.\n    // Parentheses and commas are optional, but not required.\n    // Whitespace can take the place of commas or opening paren\n    var PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n    var PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n\n    return {\n        CSS_UNIT: new RegExp(CSS_UNIT),\n        rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n        rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n        hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n        hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n        hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n        hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n    };\n})();\n\n// isValidCSSUnit\n// Take in a single string / number and check to see if it looks like a CSS unit\n// (see matchers above for definition).\nfunction isValidCSSUnit(color) {\n    return !!matchers.CSS_UNIT.exec(color);\n}\n\n// stringInputToObject\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns { r, g, b } or { h, s, l } or { h, s, v}\nfunction stringInputToObject(color) {\n\n    color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();\n    var named = false;\n    if (names[color]) {\n        color = names[color];\n        named = true;\n    }\n    else if (color == 'transparent') {\n        return { r: 0, g: 0, b: 0, a: 0, format: \"name\" };\n    }\n\n    // Try to match string input using regular expressions.\n    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n    // Just return an object and let the conversion functions handle that.\n    // This way the result will be the same whether the tinycolor is initialized with string or object.\n    var match;\n    if ((match = matchers.rgb.exec(color))) {\n        return { r: match[1], g: match[2], b: match[3] };\n    }\n    if ((match = matchers.rgba.exec(color))) {\n        return { r: match[1], g: match[2], b: match[3], a: match[4] };\n    }\n    if ((match = matchers.hsl.exec(color))) {\n        return { h: match[1], s: match[2], l: match[3] };\n    }\n    if ((match = matchers.hsla.exec(color))) {\n        return { h: match[1], s: match[2], l: match[3], a: match[4] };\n    }\n    if ((match = matchers.hsv.exec(color))) {\n        return { h: match[1], s: match[2], v: match[3] };\n    }\n    if ((match = matchers.hsva.exec(color))) {\n        return { h: match[1], s: match[2], v: match[3], a: match[4] };\n    }\n    if ((match = matchers.hex8.exec(color))) {\n        return {\n            r: parseIntFromHex(match[1]),\n            g: parseIntFromHex(match[2]),\n            b: parseIntFromHex(match[3]),\n            a: convertHexToDecimal(match[4]),\n            format: named ? \"name\" : \"hex8\"\n        };\n    }\n    if ((match = matchers.hex6.exec(color))) {\n        return {\n            r: parseIntFromHex(match[1]),\n            g: parseIntFromHex(match[2]),\n            b: parseIntFromHex(match[3]),\n            format: named ? \"name\" : \"hex\"\n        };\n    }\n    if ((match = matchers.hex4.exec(color))) {\n        return {\n            r: parseIntFromHex(match[1] + '' + match[1]),\n            g: parseIntFromHex(match[2] + '' + match[2]),\n            b: parseIntFromHex(match[3] + '' + match[3]),\n            a: convertHexToDecimal(match[4] + '' + match[4]),\n            format: named ? \"name\" : \"hex8\"\n        };\n    }\n    if ((match = matchers.hex3.exec(color))) {\n        return {\n            r: parseIntFromHex(match[1] + '' + match[1]),\n            g: parseIntFromHex(match[2] + '' + match[2]),\n            b: parseIntFromHex(match[3] + '' + match[3]),\n            format: named ? \"name\" : \"hex\"\n        };\n    }\n\n    return false;\n}\n\nfunction validateWCAG2Parms(parms) {\n    // return valid WCAG2 parms for isReadable.\n    // If input parms are invalid, return {\"level\":\"AA\", \"size\":\"small\"}\n    var level, size;\n    parms = parms || {\"level\":\"AA\", \"size\":\"small\"};\n    level = (parms.level || \"AA\").toUpperCase();\n    size = (parms.size || \"small\").toLowerCase();\n    if (level !== \"AA\" && level !== \"AAA\") {\n        level = \"AA\";\n    }\n    if (size !== \"small\" && size !== \"large\") {\n        size = \"small\";\n    }\n    return {\"level\":level, \"size\":size};\n}\n\nthis.tinycolor = tinycolor;\n\n})()`;\n}\n// It is hacky way to make this function will be compiled preferentially by less\n// resolve error: `ReferenceError: colorPalette is not defined`\n// https://github.com/ant-design/ant-motion/issues/44\n.tinyColorMixin();\n","@import '../themes/index';\n\n.reset-component() {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  color: @text-color;\n  font-size: @font-size-base;\n  font-variant: @font-variant-base;\n  line-height: @line-height-base;\n  list-style: none;\n  font-feature-settings: @font-feature-settings-base;\n}\n","@media screen and (max-width: @screen-md) {\n  .@{backtop-prefix-cls} {\n    right: 60px;\n  }\n}\n\n@media screen and (max-width: @screen-xs) {\n  .@{backtop-prefix-cls} {\n    right: 20px;\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/antd/lib/back-top/style/index.less":
/*!*********************************************************!*\
  !*** ./node_modules/antd/lib/back-top/style/index.less ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_less_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../css-loader/dist/cjs.js!../../../../less-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./index.less */ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/antd/lib/back-top/style/index.less");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_less_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_index_less__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_less_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_index_less__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdG50eC9yZW1pbmQvLi9ub2RlX21vZHVsZXMvYW50ZC9saWIvYmFjay10b3AvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHRudHgvcmVtaW5kLy4vbm9kZV9tb2R1bGVzL2FudGQvbGliL2JhY2stdG9wL3N0eWxlL2luZGV4LmpzIiwid2VicGFjazovL0B0bnR4L3JlbWluZC8uL25vZGVfbW9kdWxlcy9hbnRkL2xpYi9iYWNrLXRvcC9zdHlsZS9pbmRleC5sZXNzIiwid2VicGFjazovL0B0bnR4L3JlbWluZC8uL25vZGVfbW9kdWxlcy9hbnRkL2xpYi9iYWNrLXRvcC9zdHlsZS9pbmRleC5sZXNzPzg5MTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7O0FBRWIsOEJBQThCLG1CQUFPLENBQUMsc0hBQStDOztBQUVyRiw2QkFBNkIsbUJBQU8sQ0FBQyxvSEFBOEM7O0FBRW5GLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGVBQWtCOztBQUVsQix1Q0FBdUMsbUJBQU8sQ0FBQyx3RkFBZ0M7O0FBRS9FLDhDQUE4QyxtQkFBTyxDQUFDLHNHQUF1Qzs7QUFFN0YsNkNBQTZDLG1CQUFPLENBQUMsb0dBQXNDOztBQUUzRixvQ0FBb0MsbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFbkQsdUNBQXVDLG1CQUFPLENBQUMsdURBQVc7O0FBRTFELCtDQUErQyxtQkFBTyxDQUFDLDRGQUFrQzs7QUFFekYsOENBQThDLG1CQUFPLENBQUMsNEZBQWtDOztBQUV4Rix5Q0FBeUMsbUJBQU8sQ0FBQyxzREFBWTs7QUFFN0QsbUNBQW1DLG1CQUFPLENBQUMsNERBQWtCOztBQUU3RCx1REFBdUQsbUJBQU8sQ0FBQyxnSEFBNEM7O0FBRTNHLGdDQUFnQyxtQkFBTyxDQUFDLG9HQUFtQzs7QUFFM0Usc0JBQXNCLG1CQUFPLENBQUMsNEVBQW9COztBQUVsRCx3Q0FBd0MsbUJBQU8sQ0FBQyxzRUFBb0I7O0FBRXBFLHVDQUF1QyxtQkFBTyxD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LFVBQVUsS0FBSyxTQUFTLHVDQUF1QyxpRkFBaUYsd0JBQXdCLHlCQUF5QiwrQkFBK0IsdUJBQXVCLE9BQU8sd0NBQXdDLGtCQUFrQiw0Q0FBNEMsT0FBTyxrWEFBa1gsK0NBQStDLGtCQUFrQix5Q0FBeUMsT0FBTyxnREFBZ0Qsa0JBQWtCLHNEQUFzRCxPQUFPLCtDQUErQyxrQkFBa0IseUNBQXlDLE9BQU8sZ0RBQWdELGtCQUFrQixzREFBc0QsT0FBTywrQ0FBK0Msa0JBQWtCLHlDQUF5QyxPQUFPLGdEQUFnRCxrQkFBa0Isc0RBQXNELE9BQU8sZ0RBQWdELGtCQUFrQiw2T0FBNk8sT0FBTyxnREFBZ0Qsa0JBQWtCLDZMQUE2TCxPQUFPLGdEQUFnRCxrQkFBa0IsNlNBQTZTLE9BQU8sZ0RBQWdELGtCQUFrQiw2T0FBNk8sT0FBTyxxQkFBcUIsR0FBRyx3Q0FBd0MsOEZBQThGLHFDQUFxQyxzQkFBc0Isd0JBQXdCLHNDQUFzQyxvREFBb0QscURBQXFELGtEQUFrRCx5QkFBeUIsT0FBTyxxREFBcUQsMkJBQTJCLE9BQU8sY0FBYyxnQ0FBZ0MsR0FBRywrQkFBK0IsS0FBSyxLQUFLLEdBQUcsOE5BQThOLCtCQUErQix3QkFBd0IsMkJBQTJCLGNBQWMsZUFBZSx1QkFBdUIsK0JBQStCLHFDQUFxQyxtQ0FBbUMscUJBQXFCLHVEQUF1RCxHQUFHLGdEQUFnRCxPQUFPLG1CQUFtQixFQUFFLGtCQUFrQixLQUFLLEdBQUcsK0NBQStDLE9BQU8sbUJBQW1CLEVBQUUsa0JBQWtCLEtBQUssR0FBRyxxQkFBcUI7QUFDMXF5QztBQUNBLGlFQUFlLHVCQUF1QixFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUDhDO0FBQ3JGLFlBQW9KOztBQUVwSjs7QUFFQTtBQUNBOztBQUVBLGFBQWEsNkZBQUcsQ0FBQyx1SEFBTzs7OztBQUl4QixpRUFBZSw4SEFBYyxNQUFNLEUiLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYW50ZF9saWJfYmFjay10b3BfaS5kODQ3M2JkOGNiNzFiNTdmNDUwYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX2V4dGVuZHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiKSk7XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcmNNb3Rpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyYy1tb3Rpb25cIikpO1xuXG52YXIgX2FkZEV2ZW50TGlzdGVuZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyYy11dGlsL2xpYi9Eb20vYWRkRXZlbnRMaXN0ZW5lclwiKSk7XG5cbnZhciBfdXNlTWVyZ2VkU3RhdGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmMtdXRpbC9saWIvaG9va3MvdXNlTWVyZ2VkU3RhdGVcIikpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcblxudmFyIF9vbWl0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmMtdXRpbC9saWIvb21pdFwiKSk7XG5cbnZhciBfVmVydGljYWxBbGlnblRvcE91dGxpbmVkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFudC1kZXNpZ24vaWNvbnMvVmVydGljYWxBbGlnblRvcE91dGxpbmVkXCIpKTtcblxudmFyIF90aHJvdHRsZUJ5QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi4vX3V0aWwvdGhyb3R0bGVCeUFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgX2NvbmZpZ1Byb3ZpZGVyID0gcmVxdWlyZShcIi4uL2NvbmZpZy1wcm92aWRlclwiKTtcblxudmFyIF9nZXRTY3JvbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9fdXRpbC9nZXRTY3JvbGxcIikpO1xuXG52YXIgX3Njcm9sbFRvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vX3V0aWwvc2Nyb2xsVG9cIikpO1xuXG52YXIgX3JlYWN0Tm9kZSA9IHJlcXVpcmUoXCIuLi9fdXRpbC9yZWFjdE5vZGVcIik7XG5cbnZhciBCYWNrVG9wID0gZnVuY3Rpb24gQmFja1RvcChwcm9wcykge1xuICB2YXIgX3VzZU1lcmdlZFN0YXRlID0gKDAsIF91c2VNZXJnZWRTdGF0ZTNbXCJkZWZhdWx0XCJdKShmYWxzZSwge1xuICAgIHZhbHVlOiBwcm9wcy52aXNpYmxlXG4gIH0pLFxuICAgICAgX3VzZU1lcmdlZFN0YXRlMiA9ICgwLCBfc2xpY2VkVG9BcnJheTJbXCJkZWZhdWx0XCJdKShfdXNlTWVyZ2VkU3RhdGUsIDIpLFxuICAgICAgdmlzaWJsZSA9IF91c2VNZXJnZWRTdGF0ZTJbMF0sXG4gICAgICBzZXRWaXNpYmxlID0gX3VzZU1lcmdlZFN0YXRlMlsxXTtcblxuICB2YXIgcmVmID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICB2YXIgc2Nyb2xsRXZlbnQgPSBSZWFjdC51c2VSZWYoKTtcblxuICB2YXIgZ2V0RGVmYXVsdFRhcmdldCA9IGZ1bmN0aW9uIGdldERlZmF1bHRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50Lm93bmVyRG9jdW1lbnQgPyByZWYuY3VycmVudC5vd25lckRvY3VtZW50IDogd2luZG93O1xuICB9O1xuXG4gIHZhciBoYW5kbGVTY3JvbGwgPSAoMCwgX3Rocm90dGxlQnlBbmltYXRpb25GcmFtZS50aHJvdHRsZUJ5QW5pbWF0aW9uRnJhbWUpKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHZpc2liaWxpdHlIZWlnaHQgPSBwcm9wcy52aXNpYmlsaXR5SGVpZ2h0O1xuICAgIHZhciBzY3JvbGxUb3AgPSAoMCwgX2dldFNjcm9sbFtcImRlZmF1bHRcIl0pKGUudGFyZ2V0LCB0cnVlKTtcbiAgICBzZXRWaXNpYmxlKHNjcm9sbFRvcCA+IHZpc2liaWxpdHlIZWlnaHQpO1xuICB9KTtcblxuICB2YXIgYmluZFNjcm9sbEV2ZW50ID0gZnVuY3Rpb24gYmluZFNjcm9sbEV2ZW50KCkge1xuICAgIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgdmFyIGdldFRhcmdldCA9IHRhcmdldCB8fCBnZXREZWZhdWx0VGFyZ2V0O1xuICAgIHZhciBjb250YWluZXIgPSBnZXRUYXJnZXQoKTtcbiAgICBzY3JvbGxFdmVudC5jdXJyZW50ID0gKDAsIF9hZGRFdmVudExpc3RlbmVyW1wiZGVmYXVsdFwiXSkoY29udGFpbmVyLCAnc2Nyb2xsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGhhbmRsZVNjcm9sbChlKTtcbiAgICB9KTtcbiAgICBoYW5kbGVTY3JvbGwoe1xuICAgICAgdGFyZ2V0OiBjb250YWluZXJcbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGJpbmRTY3JvbGxFdmVudCgpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2Nyb2xsRXZlbnQuY3VycmVudCkge1xuICAgICAgICBzY3JvbGxFdmVudC5jdXJyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVTY3JvbGwuY2FuY2VsKCk7XG4gICAgfTtcbiAgfSwgW3Byb3BzLnRhcmdldF0pO1xuXG4gIHZhciBzY3JvbGxUb1RvcCA9IGZ1bmN0aW9uIHNjcm9sbFRvVG9wKGUpIHtcbiAgICB2YXIgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssXG4gICAgICAgIHRhcmdldCA9IHByb3BzLnRhcmdldCxcbiAgICAgICAgX3Byb3BzJGR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uID0gX3Byb3BzJGR1cmF0aW9uID09PSB2b2lkIDAgPyA0NTAgOiBfcHJvcHMkZHVyYXRpb247XG4gICAgKDAsIF9zY3JvbGxUb1tcImRlZmF1bHRcIl0pKDAsIHtcbiAgICAgIGdldENvbnRhaW5lcjogdGFyZ2V0IHx8IGdldERlZmF1bHRUYXJnZXQsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25DbGljayhlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oX3JlZikge1xuICAgIHZhciBwcmVmaXhDbHMgPSBfcmVmLnByZWZpeENscyxcbiAgICAgICAgcm9vdFByZWZpeENscyA9IF9yZWYucm9vdFByZWZpeENscztcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgZGVmYXVsdEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeENscywgXCItY29udGVudFwiKVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQocHJlZml4Q2xzLCBcIi1pY29uXCIpXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX1ZlcnRpY2FsQWxpZ25Ub3BPdXRsaW5lZFtcImRlZmF1bHRcIl0sIG51bGwpKSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9yY01vdGlvbltcImRlZmF1bHRcIl0sIHtcbiAgICAgIHZpc2libGU6IHZpc2libGUsXG4gICAgICBtb3Rpb25OYW1lOiBcIlwiLmNvbmNhdChyb290UHJlZml4Q2xzLCBcIi1mYWRlXCIpLFxuICAgICAgcmVtb3ZlT25MZWF2ZTogdHJ1ZVxuICAgIH0sIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIG1vdGlvbkNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZTtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlbiB8fCBkZWZhdWx0RWxlbWVudDtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAoMCwgX3JlYWN0Tm9kZS5jbG9uZUVsZW1lbnQpKGNoaWxkTm9kZSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBfcmVmMy5jbGFzc05hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShtb3Rpb25DbGFzc05hbWUsIGNsYXNzTmFtZSlcbiAgICAgICAgfTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KF9jb25maWdQcm92aWRlci5Db25maWdDb250ZXh0KSxcbiAgICAgIGdldFByZWZpeENscyA9IF9SZWFjdCR1c2VDb250ZXh0LmdldFByZWZpeENscyxcbiAgICAgIGRpcmVjdGlvbiA9IF9SZWFjdCR1c2VDb250ZXh0LmRpcmVjdGlvbjtcblxuICB2YXIgY3VzdG9taXplUHJlZml4Q2xzID0gcHJvcHMucHJlZml4Q2xzLFxuICAgICAgX3Byb3BzJGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9wcm9wcyRjbGFzc05hbWUgPT09IHZvaWQgMCA/ICcnIDogX3Byb3BzJGNsYXNzTmFtZTtcbiAgdmFyIHByZWZpeENscyA9IGdldFByZWZpeENscygnYmFjay10b3AnLCBjdXN0b21pemVQcmVmaXhDbHMpO1xuICB2YXIgcm9vdFByZWZpeENscyA9IGdldFByZWZpeENscygpO1xuICB2YXIgY2xhc3NTdHJpbmcgPSAoMCwgX2NsYXNzbmFtZXNbXCJkZWZhdWx0XCJdKShwcmVmaXhDbHMsICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoe30sIFwiXCIuY29uY2F0KHByZWZpeENscywgXCItcnRsXCIpLCBkaXJlY3Rpb24gPT09ICdydGwnKSwgY2xhc3NOYW1lKTsgLy8gZml4IGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wXG5cbiAgdmFyIGRpdlByb3BzID0gKDAsIF9vbWl0W1wiZGVmYXVsdFwiXSkocHJvcHMsIFsncHJlZml4Q2xzJywgJ2NsYXNzTmFtZScsICdjaGlsZHJlbicsICd2aXNpYmlsaXR5SGVpZ2h0JywgJ3RhcmdldCcsICd2aXNpYmxlJ10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgKDAsIF9leHRlbmRzMltcImRlZmF1bHRcIl0pKHt9LCBkaXZQcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NTdHJpbmcsXG4gICAgb25DbGljazogc2Nyb2xsVG9Ub3AsXG4gICAgcmVmOiByZWZcbiAgfSksIHJlbmRlckNoaWxkcmVuKHtcbiAgICBwcmVmaXhDbHM6IHByZWZpeENscyxcbiAgICByb290UHJlZml4Q2xzOiByb290UHJlZml4Q2xzXG4gIH0pKTtcbn07XG5cbkJhY2tUb3AuZGVmYXVsdFByb3BzID0ge1xuICB2aXNpYmlsaXR5SGVpZ2h0OiA0MDBcbn07XG5cbnZhciBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKEJhY2tUb3ApO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiLi4vLi4vc3R5bGUvaW5kZXgubGVzc1wiKTtcblxucmVxdWlyZShcIi4vaW5kZXgubGVzc1wiKTsiLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBzdHlsZWxpbnQtZGlzYWJsZSBhdC1ydWxlLWVtcHR5LWxpbmUtYmVmb3JlLGF0LXJ1bGUtbmFtZS1zcGFjZS1hZnRlcixhdC1ydWxlLW5vLXVua25vd24gKi9cXG4vKiBzdHlsZWxpbnQtZGlzYWJsZSBuby1kdXBsaWNhdGUtc2VsZWN0b3JzICovXFxuLyogc3R5bGVsaW50LWRpc2FibGUgKi9cXG4vKiBzdHlsZWxpbnQtZGlzYWJsZSBkZWNsYXJhdGlvbi1iYW5nLXNwYWNlLWJlZm9yZSxuby1kdXBsaWNhdGUtc2VsZWN0b3JzLHN0cmluZy1uby1uZXdsaW5lICovXFxuLmFudC1iYWNrLXRvcCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZm9udC12YXJpYW50OiB0YWJ1bGFyLW51bXM7XFxuICBsaW5lLWhlaWdodDogMS41NzE1O1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogJ3RudW0nO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgcmlnaHQ6IDEwMHB4O1xcbiAgYm90dG9tOiA1MHB4O1xcbiAgei1pbmRleDogMTA7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmFudC1iYWNrLXRvcDplbXB0eSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uYW50LWJhY2stdG9wLXJ0bCB7XFxuICByaWdodDogYXV0bztcXG4gIGxlZnQ6IDEwMHB4O1xcbiAgZGlyZWN0aW9uOiBydGw7XFxufVxcbi5hbnQtYmFjay10b3AtY29udGVudCB7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBjb2xvcjogI2ZmZjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40NSk7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3M7XFxufVxcbi5hbnQtYmFjay10b3AtY29udGVudDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3M7XFxufVxcbi5hbnQtYmFjay10b3AtaWNvbiB7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICBsaW5lLWhlaWdodDogNDBweDtcXG59XFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzY4cHgpIHtcXG4gIC5hbnQtYmFjay10b3Age1xcbiAgICByaWdodDogNjBweDtcXG4gIH1cXG59XFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDgwcHgpIHtcXG4gIC5hbnQtYmFjay10b3Age1xcbiAgICByaWdodDogMjBweDtcXG4gIH1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL2FudGQvbGliL2JhY2stdG9wL3N0eWxlL2luZGV4Lmxlc3NcIixcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9hbnRkL2xpYi9zdHlsZS9jb2xvci90aW55Q29sb3IubGVzc1wiLFwid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL2FudGQvbGliL3N0eWxlL21peGlucy9yZXNldC5sZXNzXCIsXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvYW50ZC9saWIvYmFjay10b3Avc3R5bGUvcmVzcG9uc2l2ZS5sZXNzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLDRGQUE0RjtBQUM1Riw2Q0FBNkM7QUFDN0Msc0JBQXNCO0FBQ3RCLDZGQUE2RjtBQ0g1RjtFQ0dDLHNCQUFBO0VBQ0EsU0FBQTtFQUNBLFVBQUE7RUFDQSwwQkFBQTtFQUNBLGVBQUE7RUFDQSwwQkFBQTtFQUNBLG1CQUFBO0VBQ0EsZ0JBQUE7RUFDQSw2QkFBQTtFRkhBLGVBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSxXQUFBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7QUFPRjtBQUxFO0VBQ0UsYUFBQTtBQU9KO0FBSkU7RUFDRSxXQUFBO0VBQ0EsV0FBQTtFQUNBLGNBQUE7QUFNSjtBQUhFO0VBQ0UsV0FBQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtFQUNBLFdBQUE7RUFDQSxrQkFBQTtFQUNBLHFDQUFBO0VBQ0EsbUJBQUE7RUFDQSxvQkFBQTtBQUtKO0FBSEk7RUFDRSxxQ0FBQTtFQUNBLG9CQUFBO0FBS047QUFERTtFQUNFLGVBQUE7RUFDQSxpQkFBQTtBQUdKO0FHL0NBO0VGQUM7SUVFRyxXQUFBO0VIaURGO0FBQ0Y7QUc5Q0E7RUZOQztJRVFHLFdBQUE7RUhnREY7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0ICcuLi8uLi9zdHlsZS90aGVtZXMvaW5kZXgnO1xcbkBpbXBvcnQgJy4uLy4uL3N0eWxlL21peGlucy9pbmRleCc7XFxuXFxuQGJhY2t0b3AtcHJlZml4LWNsczogfidAe2FudC1wcmVmaXh9LWJhY2stdG9wJztcXG5cXG4uQHtiYWNrdG9wLXByZWZpeC1jbHN9IHtcXG4gIC5yZXNldC1jb21wb25lbnQoKTtcXG5cXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHJpZ2h0OiAxMDBweDtcXG4gIGJvdHRvbTogNTBweDtcXG4gIHotaW5kZXg6IEB6aW5kZXgtYmFjay10b3A7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG5cXG4gICY6ZW1wdHkge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgJi1ydGwge1xcbiAgICByaWdodDogYXV0bztcXG4gICAgbGVmdDogMTAwcHg7XFxuICAgIGRpcmVjdGlvbjogcnRsO1xcbiAgfVxcblxcbiAgJi1jb250ZW50IHtcXG4gICAgd2lkdGg6IDQwcHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgY29sb3I6IEBiYWNrLXRvcC1jb2xvcjtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBAYmFjay10b3AtYmc7XFxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzO1xcblxcbiAgICAmOmhvdmVyIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBAYmFjay10b3AtaG92ZXItYmc7XFxuICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3M7XFxuICAgIH1cXG4gIH1cXG5cXG4gICYtaWNvbiB7XFxuICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICB9XFxufVxcblxcbkBpbXBvcnQgJy4vcmVzcG9uc2l2ZSc7XFxuXCIsXCIvKiBzdHlsZWxpbnQtZGlzYWJsZSBkZWNsYXJhdGlvbi1iYW5nLXNwYWNlLWJlZm9yZSxuby1kdXBsaWNhdGUtc2VsZWN0b3JzLHN0cmluZy1uby1uZXdsaW5lICovXFxuLnRpbnlDb2xvck1peGluKCkge1xcbkBmdW5jdGlvbnM6IH5gKGZ1bmN0aW9uKCkge1xcbi8vIFRpbnlDb2xvciB2MS40LjFcXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL1RpbnlDb2xvclxcbi8vIDIwMTYtMDctMDcsIEJyaWFuIEdyaW5zdGVhZCwgTUlUIExpY2Vuc2VcXG52YXIgdHJpbUxlZnQgPSAvXlxcXFxzKy8sXFxuICAgIHRyaW1SaWdodCA9IC9cXFxccyskLyxcXG4gICAgdGlueUNvdW50ZXIgPSAwLFxcbiAgICBtYXRoUm91bmQgPSBNYXRoLnJvdW5kLFxcbiAgICBtYXRoTWluID0gTWF0aC5taW4sXFxuICAgIG1hdGhNYXggPSBNYXRoLm1heCxcXG4gICAgbWF0aFJhbmRvbSA9IE1hdGgucmFuZG9tO1xcblxcbmZ1bmN0aW9uIHRpbnljb2xvciAoY29sb3IsIG9wdHMpIHtcXG5cXG4gICAgY29sb3IgPSAoY29sb3IpID8gY29sb3IgOiAnJztcXG4gICAgb3B0cyA9IG9wdHMgfHwgeyB9O1xcblxcbiAgICAvLyBJZiBpbnB1dCBpcyBhbHJlYWR5IGEgdGlueWNvbG9yLCByZXR1cm4gaXRzZWxmXFxuICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIHRpbnljb2xvcikge1xcbiAgICAgICByZXR1cm4gY29sb3I7XFxuICAgIH1cXG4gICAgLy8gSWYgd2UgYXJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBjYWxsIHVzaW5nIG5ldyBpbnN0ZWFkXFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XFxuICAgICAgICByZXR1cm4gbmV3IHRpbnljb2xvcihjb2xvciwgb3B0cyk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJnYiA9IGlucHV0VG9SR0IoY29sb3IpO1xcbiAgICB0aGlzLl9vcmlnaW5hbElucHV0ID0gY29sb3IsXFxuICAgIHRoaXMuX3IgPSByZ2IucixcXG4gICAgdGhpcy5fZyA9IHJnYi5nLFxcbiAgICB0aGlzLl9iID0gcmdiLmIsXFxuICAgIHRoaXMuX2EgPSByZ2IuYSxcXG4gICAgdGhpcy5fcm91bmRBID0gbWF0aFJvdW5kKDEwMCp0aGlzLl9hKSAvIDEwMCxcXG4gICAgdGhpcy5fZm9ybWF0ID0gb3B0cy5mb3JtYXQgfHwgcmdiLmZvcm1hdDtcXG4gICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XFxuXFxuICAgIC8vIERvbid0IGxldCB0aGUgcmFuZ2Ugb2YgWzAsMjU1XSBjb21lIGJhY2sgaW4gWzAsMV0uXFxuICAgIC8vIFBvdGVudGlhbGx5IGxvc2UgYSBsaXR0bGUgYml0IG9mIHByZWNpc2lvbiBoZXJlLCBidXQgd2lsbCBmaXggaXNzdWVzIHdoZXJlXFxuICAgIC8vIC41IGdldHMgaW50ZXJwcmV0ZWQgYXMgaGFsZiBvZiB0aGUgdG90YWwsIGluc3RlYWQgb2YgaGFsZiBvZiAxXFxuICAgIC8vIElmIGl0IHdhcyBzdXBwb3NlZCB0byBiZSAxMjgsIHRoaXMgd2FzIGFscmVhZHkgdGFrZW4gY2FyZSBvZiBieSBpbnB1dFRvUmdiXFxuICAgIGlmICh0aGlzLl9yIDwgMSkgeyB0aGlzLl9yID0gbWF0aFJvdW5kKHRoaXMuX3IpOyB9XFxuICAgIGlmICh0aGlzLl9nIDwgMSkgeyB0aGlzLl9nID0gbWF0aFJvdW5kKHRoaXMuX2cpOyB9XFxuICAgIGlmICh0aGlzLl9iIDwgMSkgeyB0aGlzLl9iID0gbWF0aFJvdW5kKHRoaXMuX2IpOyB9XFxuXFxuICAgIHRoaXMuX29rID0gcmdiLm9rO1xcbiAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XFxufVxcblxcbnRpbnljb2xvci5wcm90b3R5cGUgPSB7XFxuICAgIGlzRGFyazogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCcmlnaHRuZXNzKCkgPCAxMjg7XFxuICAgIH0sXFxuICAgIGlzTGlnaHQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRGFyaygpO1xcbiAgICB9LFxcbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9vaztcXG4gICAgfSxcXG4gICAgZ2V0T3JpZ2luYWxJbnB1dDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsSW5wdXQ7XFxuICAgIH0sXFxuICAgIGdldEZvcm1hdDogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0O1xcbiAgICB9LFxcbiAgICBnZXRBbHBoYTogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYTtcXG4gICAgfSxcXG4gICAgZ2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XFxuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL0FFUlQjY29sb3ItY29udHJhc3RcXG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XFxuICAgICAgICByZXR1cm4gKHJnYi5yICogMjk5ICsgcmdiLmcgKiA1ODcgKyByZ2IuYiAqIDExNCkgLyAxMDAwO1xcbiAgICB9LFxcbiAgICBnZXRMdW1pbmFuY2U6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXFxuICAgICAgICB2YXIgcmdiID0gdGhpcy50b1JnYigpO1xcbiAgICAgICAgdmFyIFJzUkdCLCBHc1JHQiwgQnNSR0IsIFIsIEcsIEI7XFxuICAgICAgICBSc1JHQiA9IHJnYi5yLzI1NTtcXG4gICAgICAgIEdzUkdCID0gcmdiLmcvMjU1O1xcbiAgICAgICAgQnNSR0IgPSByZ2IuYi8yNTU7XFxuXFxuICAgICAgICBpZiAoUnNSR0IgPD0gMC4wMzkyOCkge1IgPSBSc1JHQiAvIDEyLjkyO30gZWxzZSB7UiA9IE1hdGgucG93KCgoUnNSR0IgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7fVxcbiAgICAgICAgaWYgKEdzUkdCIDw9IDAuMDM5MjgpIHtHID0gR3NSR0IgLyAxMi45Mjt9IGVsc2Uge0cgPSBNYXRoLnBvdygoKEdzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cXG4gICAgICAgIGlmIChCc1JHQiA8PSAwLjAzOTI4KSB7QiA9IEJzUkdCIC8gMTIuOTI7fSBlbHNlIHtCID0gTWF0aC5wb3coKChCc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XFxuICAgICAgICByZXR1cm4gKDAuMjEyNiAqIFIpICsgKDAuNzE1MiAqIEcpICsgKDAuMDcyMiAqIEIpO1xcbiAgICB9LFxcbiAgICBzZXRBbHBoYTogZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgIHRoaXMuX2EgPSBib3VuZEFscGhhKHZhbHVlKTtcXG4gICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xcbiAgICAgICAgcmV0dXJuIHsgaDogaHN2LmggKiAzNjAsIHM6IGhzdi5zLCB2OiBoc3YudiwgYTogdGhpcy5fYSB9O1xcbiAgICB9LFxcbiAgICB0b0hzdlN0cmluZzogZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XFxuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcXG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XFxuICAgICAgICAgIFxcXCJoc3YoXFxcIiAgKyBoICsgXFxcIiwgXFxcIiArIHMgKyBcXFwiJSwgXFxcIiArIHYgKyBcXFwiJSlcXFwiIDpcXG4gICAgICAgICAgXFxcImhzdmEoXFxcIiArIGggKyBcXFwiLCBcXFwiICsgcyArIFxcXCIlLCBcXFwiICsgdiArIFxcXCIlLCBcXFwiKyB0aGlzLl9yb3VuZEEgKyBcXFwiKVxcXCI7XFxuICAgIH0sXFxuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcXG4gICAgICAgIHJldHVybiB7IGg6IGhzbC5oICogMzYwLCBzOiBoc2wucywgbDogaHNsLmwsIGE6IHRoaXMuX2EgfTtcXG4gICAgfSxcXG4gICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xcbiAgICAgICAgdmFyIGggPSBtYXRoUm91bmQoaHNsLmggKiAzNjApLCBzID0gbWF0aFJvdW5kKGhzbC5zICogMTAwKSwgbCA9IG1hdGhSb3VuZChoc2wubCAqIDEwMCk7XFxuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xcbiAgICAgICAgICBcXFwiaHNsKFxcXCIgICsgaCArIFxcXCIsIFxcXCIgKyBzICsgXFxcIiUsIFxcXCIgKyBsICsgXFxcIiUpXFxcIiA6XFxuICAgICAgICAgIFxcXCJoc2xhKFxcXCIgKyBoICsgXFxcIiwgXFxcIiArIHMgKyBcXFwiJSwgXFxcIiArIGwgKyBcXFwiJSwgXFxcIisgdGhpcy5fcm91bmRBICsgXFxcIilcXFwiO1xcbiAgICB9LFxcbiAgICB0b0hleDogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xcbiAgICAgICAgcmV0dXJuIHJnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIGFsbG93M0NoYXIpO1xcbiAgICB9LFxcbiAgICB0b0hleFN0cmluZzogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xcbiAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXgoYWxsb3czQ2hhcik7XFxuICAgIH0sXFxuICAgIHRvSGV4ODogZnVuY3Rpb24oYWxsb3c0Q2hhcikge1xcbiAgICAgICAgcmV0dXJuIHJnYmFUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hLCBhbGxvdzRDaGFyKTtcXG4gICAgfSxcXG4gICAgdG9IZXg4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzRDaGFyKSB7XFxuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy50b0hleDgoYWxsb3c0Q2hhcik7XFxuICAgIH0sXFxuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZCh0aGlzLl9yKSwgZzogbWF0aFJvdW5kKHRoaXMuX2cpLCBiOiBtYXRoUm91bmQodGhpcy5fYiksIGE6IHRoaXMuX2EgfTtcXG4gICAgfSxcXG4gICAgdG9SZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cXG4gICAgICAgICAgXFxcInJnYihcXFwiICArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFxcXCIsIFxcXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcXFwiLCBcXFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXFxcIilcXFwiIDpcXG4gICAgICAgICAgXFxcInJnYmEoXFxcIiArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFxcXCIsIFxcXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcXFwiLCBcXFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXFxcIiwgXFxcIiArIHRoaXMuX3JvdW5kQSArIFxcXCIpXFxcIjtcXG4gICAgfSxcXG4gICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXFxcIiVcXFwiLCBnOiBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFxcXCIlXFxcIiwgYjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcXFwiJVxcXCIsIGE6IHRoaXMuX2EgfTtcXG4gICAgfSxcXG4gICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XFxuICAgICAgICAgIFxcXCJyZ2IoXFxcIiAgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFxcXCIlLCBcXFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcXFwiJSwgXFxcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXFxcIiUpXFxcIiA6XFxuICAgICAgICAgIFxcXCJyZ2JhKFxcXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFxcXCIlLCBcXFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcXFwiJSwgXFxcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXFxcIiUsIFxcXCIgKyB0aGlzLl9yb3VuZEEgKyBcXFwiKVxcXCI7XFxuICAgIH0sXFxuICAgIHRvTmFtZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidHJhbnNwYXJlbnRcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMuX2EgPCAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcXG4gICAgfSxcXG4gICAgdG9GaWx0ZXI6IGZ1bmN0aW9uKHNlY29uZENvbG9yKSB7XFxuICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0FyZ2JIZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XFxuICAgICAgICB2YXIgc2Vjb25kSGV4OFN0cmluZyA9IGhleDhTdHJpbmc7XFxuICAgICAgICB2YXIgZ3JhZGllbnRUeXBlID0gdGhpcy5fZ3JhZGllbnRUeXBlID8gXFxcIkdyYWRpZW50VHlwZSA9IDEsIFxcXCIgOiBcXFwiXFxcIjtcXG5cXG4gICAgICAgIGlmIChzZWNvbmRDb2xvcikge1xcbiAgICAgICAgICAgIHZhciBzID0gdGlueWNvbG9yKHNlY29uZENvbG9yKTtcXG4gICAgICAgICAgICBzZWNvbmRIZXg4U3RyaW5nID0gJyMnICsgcmdiYVRvQXJnYkhleChzLl9yLCBzLl9nLCBzLl9iLCBzLl9hKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KFxcXCIrZ3JhZGllbnRUeXBlK1xcXCJzdGFydENvbG9yc3RyPVxcXCIraGV4OFN0cmluZytcXFwiLGVuZENvbG9yc3RyPVxcXCIrc2Vjb25kSGV4OFN0cmluZytcXFwiKVxcXCI7XFxuICAgIH0sXFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmb3JtYXQpIHtcXG4gICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLl9mb3JtYXQ7XFxuXFxuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nID0gZmFsc2U7XFxuICAgICAgICB2YXIgaGFzQWxwaGEgPSB0aGlzLl9hIDwgMSAmJiB0aGlzLl9hID49IDA7XFxuICAgICAgICB2YXIgbmVlZHNBbHBoYUZvcm1hdCA9ICFmb3JtYXRTZXQgJiYgaGFzQWxwaGEgJiYgKGZvcm1hdCA9PT0gXFxcImhleFxcXCIgfHwgZm9ybWF0ID09PSBcXFwiaGV4NlxcXCIgfHwgZm9ybWF0ID09PSBcXFwiaGV4M1xcXCIgfHwgZm9ybWF0ID09PSBcXFwiaGV4NFxcXCIgfHwgZm9ybWF0ID09PSBcXFwiaGV4OFxcXCIgfHwgZm9ybWF0ID09PSBcXFwibmFtZVxcXCIpO1xcblxcbiAgICAgICAgaWYgKG5lZWRzQWxwaGFGb3JtYXQpIHtcXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFxcXCJ0cmFuc3BhcmVudFxcXCIsIGFsbCBvdGhlciBub24tYWxwaGEgZm9ybWF0c1xcbiAgICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIHJnYmEgd2hlbiB0aGVyZSBpcyB0cmFuc3BhcmVuY3kuXFxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXFxcIm5hbWVcXFwiICYmIHRoaXMuX2EgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OYW1lKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcXFwicmdiXFxcIikge1xcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9SZ2JTdHJpbmcoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFxcXCJwcmdiXFxcIikge1xcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9QZXJjZW50YWdlUmdiU3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcXFwiaGV4XFxcIiB8fCBmb3JtYXQgPT09IFxcXCJoZXg2XFxcIikge1xcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFxcXCJoZXgzXFxcIikge1xcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcodHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcXFwiaGV4NFxcXCIpIHtcXG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4OFN0cmluZyh0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFxcXCJoZXg4XFxcIikge1xcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcXFwibmFtZVxcXCIpIHtcXG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvTmFtZSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXFxcImhzbFxcXCIpIHtcXG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcXFwiaHN2XFxcIikge1xcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic3ZTdHJpbmcoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdHJpbmcgfHwgdGhpcy50b0hleFN0cmluZygpO1xcbiAgICB9LFxcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGlueWNvbG9yKHRoaXMudG9TdHJpbmcoKSk7XFxuICAgIH0sXFxuXFxuICAgIF9hcHBseU1vZGlmaWNhdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcXG4gICAgICAgIHZhciBjb2xvciA9IGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xcbiAgICAgICAgdGhpcy5fciA9IGNvbG9yLl9yO1xcbiAgICAgICAgdGhpcy5fZyA9IGNvbG9yLl9nO1xcbiAgICAgICAgdGhpcy5fYiA9IGNvbG9yLl9iO1xcbiAgICAgICAgdGhpcy5zZXRBbHBoYShjb2xvci5fYSk7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgbGlnaHRlbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24obGlnaHRlbiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG4gICAgYnJpZ2h0ZW46IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGJyaWdodGVuLCBhcmd1bWVudHMpO1xcbiAgICB9LFxcbiAgICBkYXJrZW46IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRhcmtlbiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG4gICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGVzYXR1cmF0ZSwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG4gICAgc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNhdHVyYXRlLCBhcmd1bWVudHMpO1xcbiAgICB9LFxcbiAgICBncmV5c2NhbGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGdyZXlzY2FsZSwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG4gICAgc3BpbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc3BpbiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgX2FwcGx5Q29tYmluYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XFxuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XFxuICAgIH0sXFxuICAgIGFuYWxvZ291czogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihhbmFsb2dvdXMsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuICAgIGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oY29tcGxlbWVudCwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG4gICAgbW9ub2Nocm9tYXRpYzogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihtb25vY2hyb21hdGljLCBhcmd1bWVudHMpO1xcbiAgICB9LFxcbiAgICBzcGxpdGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oc3BsaXRjb21wbGVtZW50LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcbiAgICB0cmlhZDogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0cmlhZCwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG4gICAgdGV0cmFkOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRldHJhZCwgYXJndW1lbnRzKTtcXG4gICAgfVxcbn07XFxuXFxuLy8gSWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBmb3JjZSAxIGludG8gXFxcIjEuMFxcXCIgdG8gaGFuZGxlIHJhdGlvcyBwcm9wZXJseVxcbi8vIFN0cmluZyBpbnB1dCByZXF1aXJlcyBcXFwiMS4wXFxcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxcbnRpbnljb2xvci5mcm9tUmF0aW8gPSBmdW5jdGlvbihjb2xvciwgb3B0cykge1xcbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICB2YXIgbmV3Q29sb3IgPSB7fTtcXG4gICAgICAgIGZvciAodmFyIGkgaW4gY29sb3IpIHtcXG4gICAgICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IFxcXCJhXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb2xvcltpXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvcltpXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb2xvciA9IG5ld0NvbG9yO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IsIG9wdHMpO1xcbn07XFxuXFxuLy8gR2l2ZW4gYSBzdHJpbmcgb3Igb2JqZWN0LCBjb252ZXJ0IHRoYXQgaW5wdXQgdG8gUkdCXFxuLy8gUG9zc2libGUgc3RyaW5nIGlucHV0czpcXG4vL1xcbi8vICAgICBcXFwicmVkXFxcIlxcbi8vICAgICBcXFwiI2YwMFxcXCIgb3IgXFxcImYwMFxcXCJcXG4vLyAgICAgXFxcIiNmZjAwMDBcXFwiIG9yIFxcXCJmZjAwMDBcXFwiXFxuLy8gICAgIFxcXCIjZmYwMDAwMDBcXFwiIG9yIFxcXCJmZjAwMDAwMFxcXCJcXG4vLyAgICAgXFxcInJnYiAyNTUgMCAwXFxcIiBvciBcXFwicmdiICgyNTUsIDAsIDApXFxcIlxcbi8vICAgICBcXFwicmdiIDEuMCAwIDBcXFwiIG9yIFxcXCJyZ2IgKDEsIDAsIDApXFxcIlxcbi8vICAgICBcXFwicmdiYSAoMjU1LCAwLCAwLCAxKVxcXCIgb3IgXFxcInJnYmEgMjU1LCAwLCAwLCAxXFxcIlxcbi8vICAgICBcXFwicmdiYSAoMS4wLCAwLCAwLCAxKVxcXCIgb3IgXFxcInJnYmEgMS4wLCAwLCAwLCAxXFxcIlxcbi8vICAgICBcXFwiaHNsKDAsIDEwMCUsIDUwJSlcXFwiIG9yIFxcXCJoc2wgMCAxMDAlIDUwJVxcXCJcXG4vLyAgICAgXFxcImhzbGEoMCwgMTAwJSwgNTAlLCAxKVxcXCIgb3IgXFxcImhzbGEgMCAxMDAlIDUwJSwgMVxcXCJcXG4vLyAgICAgXFxcImhzdigwLCAxMDAlLCAxMDAlKVxcXCIgb3IgXFxcImhzdiAwIDEwMCUgMTAwJVxcXCJcXG4vL1xcbmZ1bmN0aW9uIGlucHV0VG9SR0IoY29sb3IpIHtcXG5cXG4gICAgdmFyIHJnYiA9IHsgcjogMCwgZzogMCwgYjogMCB9O1xcbiAgICB2YXIgYSA9IDE7XFxuICAgIHZhciBzID0gbnVsbDtcXG4gICAgdmFyIHYgPSBudWxsO1xcbiAgICB2YXIgbCA9IG51bGw7XFxuICAgIHZhciBvayA9IGZhbHNlO1xcbiAgICB2YXIgZm9ybWF0ID0gZmFsc2U7XFxuXFxuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIGNvbG9yID0gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcik7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgICAgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLnIpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmcpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLmIpKSB7XFxuICAgICAgICAgICAgcmdiID0gcmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XFxuICAgICAgICAgICAgb2sgPSB0cnVlO1xcbiAgICAgICAgICAgIGZvcm1hdCA9IFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcXFwiJVxcXCIgPyBcXFwicHJnYlxcXCIgOiBcXFwicmdiXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGlzVmFsaWRDU1NVbml0KGNvbG9yLmgpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLnMpICYmIGlzVmFsaWRDU1NVbml0KGNvbG9yLnYpKSB7XFxuICAgICAgICAgICAgcyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XFxuICAgICAgICAgICAgdiA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iudik7XFxuICAgICAgICAgICAgcmdiID0gaHN2VG9SZ2IoY29sb3IuaCwgcywgdik7XFxuICAgICAgICAgICAgb2sgPSB0cnVlO1xcbiAgICAgICAgICAgIGZvcm1hdCA9IFxcXCJoc3ZcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaXNWYWxpZENTU1VuaXQoY29sb3IuaCkgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IucykgJiYgaXNWYWxpZENTU1VuaXQoY29sb3IubCkpIHtcXG4gICAgICAgICAgICBzID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5zKTtcXG4gICAgICAgICAgICBsID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5sKTtcXG4gICAgICAgICAgICByZ2IgPSBoc2xUb1JnYihjb2xvci5oLCBzLCBsKTtcXG4gICAgICAgICAgICBvayA9IHRydWU7XFxuICAgICAgICAgICAgZm9ybWF0ID0gXFxcImhzbFxcXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXFxcImFcXFwiKSkge1xcbiAgICAgICAgICAgIGEgPSBjb2xvci5hO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGEgPSBib3VuZEFscGhhKGEpO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgICAgb2s6IG9rLFxcbiAgICAgICAgZm9ybWF0OiBjb2xvci5mb3JtYXQgfHwgZm9ybWF0LFxcbiAgICAgICAgcjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLnIsIDApKSxcXG4gICAgICAgIGc6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5nLCAwKSksXFxuICAgICAgICBiOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuYiwgMCkpLFxcbiAgICAgICAgYTogYVxcbiAgICB9O1xcbn1cXG5cXG4vLyBDb252ZXJzaW9uIEZ1bmN0aW9uc1xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuLy8gcmdiVG9Ic2wsIHJnYlRvSHN2LCBoc2xUb1JnYiwgaHN2VG9SZ2IgbW9kaWZpZWQgZnJvbTpcXG4vLyA8aHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdD5cXG5cXG4vLyByZ2JUb1JnYlxcbi8vIEhhbmRsZSBib3VuZHMgLyBwZXJjZW50YWdlIGNoZWNraW5nIHRvIGNvbmZvcm0gdG8gQ1NTIGNvbG9yIHNwZWNcXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8+XFxuLy8gKkFzc3VtZXM6KiByLCBnLCBiIGluIFswLCAyNTVdIG9yIFswLCAxXVxcbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gWzAsIDI1NV1cXG5mdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiKXtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIHI6IGJvdW5kMDEociwgMjU1KSAqIDI1NSxcXG4gICAgICAgIGc6IGJvdW5kMDEoZywgMjU1KSAqIDI1NSxcXG4gICAgICAgIGI6IGJvdW5kMDEoYiwgMjU1KSAqIDI1NVxcbiAgICB9O1xcbn1cXG5cXG4vLyByZ2JUb0hzbFxcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU0wuXFxuLy8gKkFzc3VtZXM6KiByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIFswLCAyNTVdIG9yIFswLCAxXVxcbi8vICpSZXR1cm5zOiogeyBoLCBzLCBsIH0gaW4gWzAsMV1cXG5mdW5jdGlvbiByZ2JUb0hzbChyLCBnLCBiKSB7XFxuXFxuICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XFxuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XFxuICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XFxuXFxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xcbiAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcXG5cXG4gICAgaWYobWF4ID09IG1pbikge1xcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcXG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcXG4gICAgICAgIHN3aXRjaChtYXgpIHtcXG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcXG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaCAvPSA2O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIGw6IGwgfTtcXG59XFxuXFxuLy8gaHNsVG9SZ2JcXG4vLyBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLlxcbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCBsIGFyZSBjb250YWluZWQgWzAsIDFdIG9yIFswLCAxMDBdXFxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXFxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xcbiAgICB2YXIgciwgZywgYjtcXG5cXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcXG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcXG4gICAgbCA9IGJvdW5kMDEobCwgMTAwKTtcXG5cXG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XFxuICAgICAgICBpZih0IDwgMCkgdCArPSAxO1xcbiAgICAgICAgaWYodCA+IDEpIHQgLT0gMTtcXG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xcbiAgICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XFxuICAgICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xcbiAgICAgICAgcmV0dXJuIHA7XFxuICAgIH1cXG5cXG4gICAgaWYocyA9PT0gMCkge1xcbiAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XFxuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcXG4gICAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xcbn1cXG5cXG4vLyByZ2JUb0hzdlxcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU1ZcXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBvciBbMCwgMV1cXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgdiB9IGluIFswLDFdXFxuZnVuY3Rpb24gcmdiVG9Ic3YociwgZywgYikge1xcblxcbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xcbiAgICBnID0gYm91bmQwMShnLCAyNTUpO1xcbiAgICBiID0gYm91bmQwMShiLCAyNTUpO1xcblxcbiAgICB2YXIgbWF4ID0gbWF0aE1heChyLCBnLCBiKSwgbWluID0gbWF0aE1pbihyLCBnLCBiKTtcXG4gICAgdmFyIGgsIHMsIHYgPSBtYXg7XFxuXFxuICAgIHZhciBkID0gbWF4IC0gbWluO1xcbiAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XFxuXFxuICAgIGlmKG1heCA9PSBtaW4pIHtcXG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgICBzd2l0Y2gobWF4KSB7XFxuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGggLz0gNjtcXG4gICAgfVxcbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCB2OiB2IH07XFxufVxcblxcbi8vIGhzdlRvUmdiXFxuLy8gQ29udmVydHMgYW4gSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cXG4vLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgdiBhcmUgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMTAwXVxcbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxcbiBmdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XFxuXFxuICAgIGggPSBib3VuZDAxKGgsIDM2MCkgKiA2O1xcbiAgICBzID0gYm91bmQwMShzLCAxMDApO1xcbiAgICB2ID0gYm91bmQwMSh2LCAxMDApO1xcblxcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaCksXFxuICAgICAgICBmID0gaCAtIGksXFxuICAgICAgICBwID0gdiAqICgxIC0gcyksXFxuICAgICAgICBxID0gdiAqICgxIC0gZiAqIHMpLFxcbiAgICAgICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKSxcXG4gICAgICAgIG1vZCA9IGkgJSA2LFxcbiAgICAgICAgciA9IFt2LCBxLCBwLCBwLCB0LCB2XVttb2RdLFxcbiAgICAgICAgZyA9IFt0LCB2LCB2LCBxLCBwLCBwXVttb2RdLFxcbiAgICAgICAgYiA9IFtwLCBwLCB0LCB2LCB2LCBxXVttb2RdO1xcblxcbiAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XFxufVxcblxcbi8vIHJnYlRvSGV4XFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIGhleFxcbi8vIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdXFxuLy8gUmV0dXJucyBhIDMgb3IgNiBjaGFyYWN0ZXIgaGV4XFxuZnVuY3Rpb24gcmdiVG9IZXgociwgZywgYiwgYWxsb3czQ2hhcikge1xcblxcbiAgICB2YXIgaGV4ID0gW1xcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpXFxuICAgIF07XFxuXFxuICAgIC8vIFJldHVybiBhIDMgY2hhcmFjdGVyIGhleCBpZiBwb3NzaWJsZVxcbiAgICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09IGhleFswXS5jaGFyQXQoMSkgJiYgaGV4WzFdLmNoYXJBdCgwKSA9PSBoZXhbMV0uY2hhckF0KDEpICYmIGhleFsyXS5jaGFyQXQoMCkgPT0gaGV4WzJdLmNoYXJBdCgxKSkge1xcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaGV4LmpvaW4oXFxcIlxcXCIpO1xcbn1cXG5cXG4vLyByZ2JhVG9IZXhcXG4vLyBDb252ZXJ0cyBhbiBSR0JBIGNvbG9yIHBsdXMgYWxwaGEgdHJhbnNwYXJlbmN5IHRvIGhleFxcbi8vIEFzc3VtZXMgciwgZywgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gYW5kXFxuLy8gYSBpbiBbMCwgMV0uIFJldHVybnMgYSA0IG9yIDggY2hhcmFjdGVyIHJnYmEgaGV4XFxuZnVuY3Rpb24gcmdiYVRvSGV4KHIsIGcsIGIsIGEsIGFsbG93NENoYXIpIHtcXG5cXG4gICAgdmFyIGhleCA9IFtcXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKSxcXG4gICAgICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSlcXG4gICAgXTtcXG5cXG4gICAgLy8gUmV0dXJuIGEgNCBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXFxuICAgIGlmIChhbGxvdzRDaGFyICYmIGhleFswXS5jaGFyQXQoMCkgPT0gaGV4WzBdLmNoYXJBdCgxKSAmJiBoZXhbMV0uY2hhckF0KDApID09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PSBoZXhbMl0uY2hhckF0KDEpICYmIGhleFszXS5jaGFyQXQoMCkgPT0gaGV4WzNdLmNoYXJBdCgxKSkge1xcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKSArIGhleFszXS5jaGFyQXQoMCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGhleC5qb2luKFxcXCJcXFwiKTtcXG59XFxuXFxuLy8gcmdiYVRvQXJnYkhleFxcbi8vIENvbnZlcnRzIGFuIFJHQkEgY29sb3IgdG8gYW4gQVJHQiBIZXg4IHN0cmluZ1xcbi8vIFJhcmVseSB1c2VkLCBidXQgcmVxdWlyZWQgZm9yIFxcXCJ0b0ZpbHRlcigpXFxcIlxcbmZ1bmN0aW9uIHJnYmFUb0FyZ2JIZXgociwgZywgYiwgYSkge1xcblxcbiAgICB2YXIgaGV4ID0gW1xcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKSxcXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxcbiAgICBdO1xcblxcbiAgICByZXR1cm4gaGV4LmpvaW4oXFxcIlxcXCIpO1xcbn1cXG5cXG4vLyBlcXVhbHNcXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxcbnRpbnljb2xvci5lcXVhbHMgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIpIHtcXG4gICAgaWYgKCFjb2xvcjEgfHwgIWNvbG9yMikgeyByZXR1cm4gZmFsc2U7IH1cXG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcXG59O1xcblxcbnRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRpbnljb2xvci5mcm9tUmF0aW8oe1xcbiAgICAgICAgcjogbWF0aFJhbmRvbSgpLFxcbiAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxcbiAgICAgICAgYjogbWF0aFJhbmRvbSgpXFxuICAgIH0pO1xcbn07XFxuXFxuLy8gTW9kaWZpY2F0aW9uIEZ1bmN0aW9uc1xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBUaGFua3MgdG8gbGVzcy5qcyBmb3Igc29tZSBvZiB0aGUgYmFzaWNzIGhlcmVcXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaGVhZC9sZXNzLmpzL2Jsb2IvbWFzdGVyL2xpYi9sZXNzL2Z1bmN0aW9ucy5qcz5cXG5cXG5mdW5jdGlvbiBkZXNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcXG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XFxuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XFxuICAgIGhzbC5zIC09IGFtb3VudCAvIDEwMDtcXG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcXG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xcbn1cXG5cXG5mdW5jdGlvbiBzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XFxuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xcbiAgICBoc2wucyArPSBhbW91bnQgLyAxMDA7XFxuICAgIGhzbC5zID0gY2xhbXAwMShoc2wucyk7XFxuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcXG59XFxuXFxuZnVuY3Rpb24gZ3JleXNjYWxlKGNvbG9yKSB7XFxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmRlc2F0dXJhdGUoMTAwKTtcXG59XFxuXFxuZnVuY3Rpb24gbGlnaHRlbiAoY29sb3IsIGFtb3VudCkge1xcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcXG4gICAgaHNsLmwgKz0gYW1vdW50IC8gMTAwO1xcbiAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XFxufVxcblxcbmZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yLCBhbW91bnQpIHtcXG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XFxuICAgIHZhciByZ2IgPSB0aW55Y29sb3IoY29sb3IpLnRvUmdiKCk7XFxuICAgIHJnYi5yID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLnIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcXG4gICAgcmdiLmcgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuZyAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xcbiAgICByZ2IuYiA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5iIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XFxuICAgIHJldHVybiB0aW55Y29sb3IocmdiKTtcXG59XFxuXFxuZnVuY3Rpb24gZGFya2VuIChjb2xvciwgYW1vdW50KSB7XFxuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XFxuICAgIGhzbC5sID0gY2xhbXAwMShoc2wubCk7XFxuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcXG59XFxuXFxuLy8gU3BpbiB0YWtlcyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGFtb3VudCB3aXRoaW4gWy0zNjAsIDM2MF0gaW5kaWNhdGluZyB0aGUgY2hhbmdlIG9mIGh1ZS5cXG4vLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXFxuZnVuY3Rpb24gc3Bpbihjb2xvciwgYW1vdW50KSB7XFxuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XFxuICAgIHZhciBodWUgPSAoaHNsLmggKyBhbW91bnQpICUgMzYwO1xcbiAgICBoc2wuaCA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XFxuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcXG59XFxuXFxuLy8gQ29tYmluYXRpb24gRnVuY3Rpb25zXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gVGhhbmtzIHRvIGpRdWVyeSB4Q29sb3IgZm9yIHNvbWUgb2YgdGhlIGlkZWFzIGJlaGluZCB0aGVzZVxcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vaW5mdXNpb24valF1ZXJ5LXhjb2xvci9ibG9iL21hc3Rlci9qcXVlcnkueGNvbG9yLmpzPlxcblxcbmZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcXG4gICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XFxufVxcblxcbmZ1bmN0aW9uIHRyaWFkKGNvbG9yKSB7XFxuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XFxuICAgIHZhciBoID0gaHNsLmg7XFxuICAgIHJldHVybiBbXFxuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxMjApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI0MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxcbiAgICBdO1xcbn1cXG5cXG5mdW5jdGlvbiB0ZXRyYWQoY29sb3IpIHtcXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcXG4gICAgdmFyIGggPSBoc2wuaDtcXG4gICAgcmV0dXJuIFtcXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDkwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxODApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI3MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxcbiAgICBdO1xcbn1cXG5cXG5mdW5jdGlvbiBzcGxpdGNvbXBsZW1lbnQoY29sb3IpIHtcXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcXG4gICAgdmFyIGggPSBoc2wuaDtcXG4gICAgcmV0dXJuIFtcXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSksXFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDIxNikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pXFxuICAgIF07XFxufVxcblxcbmZ1bmN0aW9uIGFuYWxvZ291cyhjb2xvciwgcmVzdWx0cywgc2xpY2VzKSB7XFxuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XFxuICAgIHNsaWNlcyA9IHNsaWNlcyB8fCAzMDtcXG5cXG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcXG4gICAgdmFyIHBhcnQgPSAzNjAgLyBzbGljZXM7XFxuICAgIHZhciByZXQgPSBbdGlueWNvbG9yKGNvbG9yKV07XFxuXFxuICAgIGZvciAoaHNsLmggPSAoKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpKSArIDcyMCkgJSAzNjA7IC0tcmVzdWx0czsgKSB7XFxuICAgICAgICBoc2wuaCA9IChoc2wuaCArIHBhcnQpICUgMzYwO1xcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKGhzbCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIG1vbm9jaHJvbWF0aWMoY29sb3IsIHJlc3VsdHMpIHtcXG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcXG4gICAgdmFyIGhzdiA9IHRpbnljb2xvcihjb2xvcikudG9Ic3YoKTtcXG4gICAgdmFyIGggPSBoc3YuaCwgcyA9IGhzdi5zLCB2ID0gaHN2LnY7XFxuICAgIHZhciByZXQgPSBbXTtcXG4gICAgdmFyIG1vZGlmaWNhdGlvbiA9IDEgLyByZXN1bHRzO1xcblxcbiAgICB3aGlsZSAocmVzdWx0cy0tKSB7XFxuICAgICAgICByZXQucHVzaCh0aW55Y29sb3IoeyBoOiBoLCBzOiBzLCB2OiB2fSkpO1xcbiAgICAgICAgdiA9ICh2ICsgbW9kaWZpY2F0aW9uKSAlIDE7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gVXRpbGl0eSBGdW5jdGlvbnNcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG50aW55Y29sb3IubWl4ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIGFtb3VudCkge1xcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDUwKTtcXG5cXG4gICAgdmFyIHJnYjEgPSB0aW55Y29sb3IoY29sb3IxKS50b1JnYigpO1xcbiAgICB2YXIgcmdiMiA9IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiKCk7XFxuXFxuICAgIHZhciBwID0gYW1vdW50IC8gMTAwO1xcblxcbiAgICB2YXIgcmdiYSA9IHtcXG4gICAgICAgIHI6ICgocmdiMi5yIC0gcmdiMS5yKSAqIHApICsgcmdiMS5yLFxcbiAgICAgICAgZzogKChyZ2IyLmcgLSByZ2IxLmcpICogcCkgKyByZ2IxLmcsXFxuICAgICAgICBiOiAoKHJnYjIuYiAtIHJnYjEuYikgKiBwKSArIHJnYjEuYixcXG4gICAgICAgIGE6ICgocmdiMi5hIC0gcmdiMS5hKSAqIHApICsgcmdiMS5hXFxuICAgIH07XFxuXFxuICAgIHJldHVybiB0aW55Y29sb3IocmdiYSk7XFxufTtcXG5cXG4vLyBSZWFkYWJpbGl0eSBGdW5jdGlvbnNcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZiAoV0NBRyBWZXJzaW9uIDIpXFxuXFxuLy8gY29udHJhc3RcXG4vLyBBbmFseXplIHRoZSAyIGNvbG9ycyBhbmQgcmV0dXJucyB0aGUgY29sb3IgY29udHJhc3QgZGVmaW5lZCBieSAoV0NBRyBWZXJzaW9uIDIpXFxudGlueWNvbG9yLnJlYWRhYmlsaXR5ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcXG4gICAgdmFyIGMxID0gdGlueWNvbG9yKGNvbG9yMSk7XFxuICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xcbiAgICByZXR1cm4gKE1hdGgubWF4KGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KSAvIChNYXRoLm1pbihjMS5nZXRMdW1pbmFuY2UoKSxjMi5nZXRMdW1pbmFuY2UoKSkrMC4wNSk7XFxufTtcXG5cXG4vLyBpc1JlYWRhYmxlXFxuLy8gRW5zdXJlIHRoYXQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBjb21iaW5hdGlvbnMgbWVldCBXQ0FHMiBndWlkZWxpbmVzLlxcbi8vIFRoZSB0aGlyZCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBPYmplY3QuXFxuLy8gICAgICB0aGUgJ2xldmVsJyBwcm9wZXJ0eSBzdGF0ZXMgJ0FBJyBvciAnQUFBJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ0FBJztcXG4vLyAgICAgIHRoZSAnc2l6ZScgcHJvcGVydHkgc3RhdGVzICdsYXJnZScgb3IgJ3NtYWxsJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ3NtYWxsJy5cXG4vLyBJZiB0aGUgZW50aXJlIG9iamVjdCBpcyBhYnNlbnQsIGlzUmVhZGFibGUgZGVmYXVsdHMgdG8ge2xldmVsOlxcXCJBQVxcXCIsc2l6ZTpcXFwic21hbGxcXFwifS5cXG5cXG4vLyAqRXhhbXBsZSpcXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcXFwiIzAwMFxcXCIsIFxcXCIjMTExXFxcIikgPT4gZmFsc2VcXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcXFwiIzAwMFxcXCIsIFxcXCIjMTExXFxcIix7bGV2ZWw6XFxcIkFBXFxcIixzaXplOlxcXCJsYXJnZVxcXCJ9KSA9PiBmYWxzZVxcbnRpbnljb2xvci5pc1JlYWRhYmxlID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIHdjYWcyKSB7XFxuICAgIHZhciByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShjb2xvcjEsIGNvbG9yMik7XFxuICAgIHZhciB3Y2FnMlBhcm1zLCBvdXQ7XFxuXFxuICAgIG91dCA9IGZhbHNlO1xcblxcbiAgICB3Y2FnMlBhcm1zID0gdmFsaWRhdGVXQ0FHMlBhcm1zKHdjYWcyKTtcXG4gICAgc3dpdGNoICh3Y2FnMlBhcm1zLmxldmVsICsgd2NhZzJQYXJtcy5zaXplKSB7XFxuICAgICAgICBjYXNlIFxcXCJBQXNtYWxsXFxcIjpcXG4gICAgICAgIGNhc2UgXFxcIkFBQWxhcmdlXFxcIjpcXG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSA0LjU7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFxcXCJBQWxhcmdlXFxcIjpcXG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSAzO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBcXFwiQUFBc21hbGxcXFwiOlxcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDc7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgcmV0dXJuIG91dDtcXG5cXG59O1xcblxcbi8vIG1vc3RSZWFkYWJsZVxcbi8vIEdpdmVuIGEgYmFzZSBjb2xvciBhbmQgYSBsaXN0IG9mIHBvc3NpYmxlIGZvcmVncm91bmQgb3IgYmFja2dyb3VuZFxcbi8vIGNvbG9ycyBmb3IgdGhhdCBiYXNlLCByZXR1cm5zIHRoZSBtb3N0IHJlYWRhYmxlIGNvbG9yLlxcbi8vIE9wdGlvbmFsbHkgcmV0dXJucyBCbGFjayBvciBXaGl0ZSBpZiB0aGUgbW9zdCByZWFkYWJsZSBjb2xvciBpcyB1bnJlYWRhYmxlLlxcbi8vICpFeGFtcGxlKlxcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUodGlueWNvbG9yLm1vc3RSZWFkYWJsZShcXFwiIzEyM1xcXCIsIFtcXFwiIzEyNFxcXCIsIFxcXCIjMTI1XFxcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczpmYWxzZX0pLnRvSGV4U3RyaW5nKCk7IC8vIFxcXCIjMTEyMjU1XFxcIlxcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUodGlueWNvbG9yLm1vc3RSZWFkYWJsZShcXFwiIzEyM1xcXCIsIFtcXFwiIzEyNFxcXCIsIFxcXCIjMTI1XFxcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlfSkudG9IZXhTdHJpbmcoKTsgIC8vIFxcXCIjZmZmZmZmXFxcIlxcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXFxcIiNhODAxNWFcXFwiLCBbXFxcIiNmYWYzZjNcXFwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XFxcIkFBQVxcXCIsc2l6ZTpcXFwibGFyZ2VcXFwifSkudG9IZXhTdHJpbmcoKTsgLy8gXFxcIiNmYWYzZjNcXFwiXFxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcXFwiI2E4MDE1YVxcXCIsIFtcXFwiI2ZhZjNmM1xcXCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6dHJ1ZSxsZXZlbDpcXFwiQUFBXFxcIixzaXplOlxcXCJzbWFsbFxcXCJ9KS50b0hleFN0cmluZygpOyAvLyBcXFwiI2ZmZmZmZlxcXCJcXG50aW55Y29sb3IubW9zdFJlYWRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9yLCBjb2xvckxpc3QsIGFyZ3MpIHtcXG4gICAgdmFyIGJlc3RDb2xvciA9IG51bGw7XFxuICAgIHZhciBiZXN0U2NvcmUgPSAwO1xcbiAgICB2YXIgcmVhZGFiaWxpdHk7XFxuICAgIHZhciBpbmNsdWRlRmFsbGJhY2tDb2xvcnMsIGxldmVsLCBzaXplIDtcXG4gICAgYXJncyA9IGFyZ3MgfHwge307XFxuICAgIGluY2x1ZGVGYWxsYmFja0NvbG9ycyA9IGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzIDtcXG4gICAgbGV2ZWwgPSBhcmdzLmxldmVsO1xcbiAgICBzaXplID0gYXJncy5zaXplO1xcblxcbiAgICBmb3IgKHZhciBpPSAwOyBpIDwgY29sb3JMaXN0Lmxlbmd0aCA7IGkrKykge1xcbiAgICAgICAgcmVhZGFiaWxpdHkgPSB0aW55Y29sb3IucmVhZGFiaWxpdHkoYmFzZUNvbG9yLCBjb2xvckxpc3RbaV0pO1xcbiAgICAgICAgaWYgKHJlYWRhYmlsaXR5ID4gYmVzdFNjb3JlKSB7XFxuICAgICAgICAgICAgYmVzdFNjb3JlID0gcmVhZGFiaWxpdHk7XFxuICAgICAgICAgICAgYmVzdENvbG9yID0gdGlueWNvbG9yKGNvbG9yTGlzdFtpXSk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHRpbnljb2xvci5pc1JlYWRhYmxlKGJhc2VDb2xvciwgYmVzdENvbG9yLCB7XFxcImxldmVsXFxcIjpsZXZlbCxcXFwic2l6ZVxcXCI6c2l6ZX0pIHx8ICFpbmNsdWRlRmFsbGJhY2tDb2xvcnMpIHtcXG4gICAgICAgIHJldHVybiBiZXN0Q29sb3I7XFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgICBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycz1mYWxzZTtcXG4gICAgICAgIHJldHVybiB0aW55Y29sb3IubW9zdFJlYWRhYmxlKGJhc2VDb2xvcixbXFxcIiNmZmZcXFwiLCBcXFwiIzAwMFxcXCJdLGFyZ3MpO1xcbiAgICB9XFxufTtcXG5cXG4vLyBCaWcgTGlzdCBvZiBDb2xvcnNcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yPlxcbnZhciBuYW1lcyA9IHRpbnljb2xvci5uYW1lcyA9IHtcXG4gICAgYWxpY2VibHVlOiBcXFwiZjBmOGZmXFxcIixcXG4gICAgYW50aXF1ZXdoaXRlOiBcXFwiZmFlYmQ3XFxcIixcXG4gICAgYXF1YTogXFxcIjBmZlxcXCIsXFxuICAgIGFxdWFtYXJpbmU6IFxcXCI3ZmZmZDRcXFwiLFxcbiAgICBhenVyZTogXFxcImYwZmZmZlxcXCIsXFxuICAgIGJlaWdlOiBcXFwiZjVmNWRjXFxcIixcXG4gICAgYmlzcXVlOiBcXFwiZmZlNGM0XFxcIixcXG4gICAgYmxhY2s6IFxcXCIwMDBcXFwiLFxcbiAgICBibGFuY2hlZGFsbW9uZDogXFxcImZmZWJjZFxcXCIsXFxuICAgIGJsdWU6IFxcXCIwMGZcXFwiLFxcbiAgICBibHVldmlvbGV0OiBcXFwiOGEyYmUyXFxcIixcXG4gICAgYnJvd246IFxcXCJhNTJhMmFcXFwiLFxcbiAgICBidXJseXdvb2Q6IFxcXCJkZWI4ODdcXFwiLFxcbiAgICBidXJudHNpZW5uYTogXFxcImVhN2U1ZFxcXCIsXFxuICAgIGNhZGV0Ymx1ZTogXFxcIjVmOWVhMFxcXCIsXFxuICAgIGNoYXJ0cmV1c2U6IFxcXCI3ZmZmMDBcXFwiLFxcbiAgICBjaG9jb2xhdGU6IFxcXCJkMjY5MWVcXFwiLFxcbiAgICBjb3JhbDogXFxcImZmN2Y1MFxcXCIsXFxuICAgIGNvcm5mbG93ZXJibHVlOiBcXFwiNjQ5NWVkXFxcIixcXG4gICAgY29ybnNpbGs6IFxcXCJmZmY4ZGNcXFwiLFxcbiAgICBjcmltc29uOiBcXFwiZGMxNDNjXFxcIixcXG4gICAgY3lhbjogXFxcIjBmZlxcXCIsXFxuICAgIGRhcmtibHVlOiBcXFwiMDAwMDhiXFxcIixcXG4gICAgZGFya2N5YW46IFxcXCIwMDhiOGJcXFwiLFxcbiAgICBkYXJrZ29sZGVucm9kOiBcXFwiYjg4NjBiXFxcIixcXG4gICAgZGFya2dyYXk6IFxcXCJhOWE5YTlcXFwiLFxcbiAgICBkYXJrZ3JlZW46IFxcXCIwMDY0MDBcXFwiLFxcbiAgICBkYXJrZ3JleTogXFxcImE5YTlhOVxcXCIsXFxuICAgIGRhcmtraGFraTogXFxcImJkYjc2YlxcXCIsXFxuICAgIGRhcmttYWdlbnRhOiBcXFwiOGIwMDhiXFxcIixcXG4gICAgZGFya29saXZlZ3JlZW46IFxcXCI1NTZiMmZcXFwiLFxcbiAgICBkYXJrb3JhbmdlOiBcXFwiZmY4YzAwXFxcIixcXG4gICAgZGFya29yY2hpZDogXFxcIjk5MzJjY1xcXCIsXFxuICAgIGRhcmtyZWQ6IFxcXCI4YjAwMDBcXFwiLFxcbiAgICBkYXJrc2FsbW9uOiBcXFwiZTk5NjdhXFxcIixcXG4gICAgZGFya3NlYWdyZWVuOiBcXFwiOGZiYzhmXFxcIixcXG4gICAgZGFya3NsYXRlYmx1ZTogXFxcIjQ4M2Q4YlxcXCIsXFxuICAgIGRhcmtzbGF0ZWdyYXk6IFxcXCIyZjRmNGZcXFwiLFxcbiAgICBkYXJrc2xhdGVncmV5OiBcXFwiMmY0ZjRmXFxcIixcXG4gICAgZGFya3R1cnF1b2lzZTogXFxcIjAwY2VkMVxcXCIsXFxuICAgIGRhcmt2aW9sZXQ6IFxcXCI5NDAwZDNcXFwiLFxcbiAgICBkZWVwcGluazogXFxcImZmMTQ5M1xcXCIsXFxuICAgIGRlZXBza3libHVlOiBcXFwiMDBiZmZmXFxcIixcXG4gICAgZGltZ3JheTogXFxcIjY5Njk2OVxcXCIsXFxuICAgIGRpbWdyZXk6IFxcXCI2OTY5NjlcXFwiLFxcbiAgICBkb2RnZXJibHVlOiBcXFwiMWU5MGZmXFxcIixcXG4gICAgZmlyZWJyaWNrOiBcXFwiYjIyMjIyXFxcIixcXG4gICAgZmxvcmFsd2hpdGU6IFxcXCJmZmZhZjBcXFwiLFxcbiAgICBmb3Jlc3RncmVlbjogXFxcIjIyOGIyMlxcXCIsXFxuICAgIGZ1Y2hzaWE6IFxcXCJmMGZcXFwiLFxcbiAgICBnYWluc2Jvcm86IFxcXCJkY2RjZGNcXFwiLFxcbiAgICBnaG9zdHdoaXRlOiBcXFwiZjhmOGZmXFxcIixcXG4gICAgZ29sZDogXFxcImZmZDcwMFxcXCIsXFxuICAgIGdvbGRlbnJvZDogXFxcImRhYTUyMFxcXCIsXFxuICAgIGdyYXk6IFxcXCI4MDgwODBcXFwiLFxcbiAgICBncmVlbjogXFxcIjAwODAwMFxcXCIsXFxuICAgIGdyZWVueWVsbG93OiBcXFwiYWRmZjJmXFxcIixcXG4gICAgZ3JleTogXFxcIjgwODA4MFxcXCIsXFxuICAgIGhvbmV5ZGV3OiBcXFwiZjBmZmYwXFxcIixcXG4gICAgaG90cGluazogXFxcImZmNjliNFxcXCIsXFxuICAgIGluZGlhbnJlZDogXFxcImNkNWM1Y1xcXCIsXFxuICAgIGluZGlnbzogXFxcIjRiMDA4MlxcXCIsXFxuICAgIGl2b3J5OiBcXFwiZmZmZmYwXFxcIixcXG4gICAga2hha2k6IFxcXCJmMGU2OGNcXFwiLFxcbiAgICBsYXZlbmRlcjogXFxcImU2ZTZmYVxcXCIsXFxuICAgIGxhdmVuZGVyYmx1c2g6IFxcXCJmZmYwZjVcXFwiLFxcbiAgICBsYXduZ3JlZW46IFxcXCI3Y2ZjMDBcXFwiLFxcbiAgICBsZW1vbmNoaWZmb246IFxcXCJmZmZhY2RcXFwiLFxcbiAgICBsaWdodGJsdWU6IFxcXCJhZGQ4ZTZcXFwiLFxcbiAgICBsaWdodGNvcmFsOiBcXFwiZjA4MDgwXFxcIixcXG4gICAgbGlnaHRjeWFuOiBcXFwiZTBmZmZmXFxcIixcXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFxcXCJmYWZhZDJcXFwiLFxcbiAgICBsaWdodGdyYXk6IFxcXCJkM2QzZDNcXFwiLFxcbiAgICBsaWdodGdyZWVuOiBcXFwiOTBlZTkwXFxcIixcXG4gICAgbGlnaHRncmV5OiBcXFwiZDNkM2QzXFxcIixcXG4gICAgbGlnaHRwaW5rOiBcXFwiZmZiNmMxXFxcIixcXG4gICAgbGlnaHRzYWxtb246IFxcXCJmZmEwN2FcXFwiLFxcbiAgICBsaWdodHNlYWdyZWVuOiBcXFwiMjBiMmFhXFxcIixcXG4gICAgbGlnaHRza3libHVlOiBcXFwiODdjZWZhXFxcIixcXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFxcXCI3ODlcXFwiLFxcbiAgICBsaWdodHNsYXRlZ3JleTogXFxcIjc4OVxcXCIsXFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcXFwiYjBjNGRlXFxcIixcXG4gICAgbGlnaHR5ZWxsb3c6IFxcXCJmZmZmZTBcXFwiLFxcbiAgICBsaW1lOiBcXFwiMGYwXFxcIixcXG4gICAgbGltZWdyZWVuOiBcXFwiMzJjZDMyXFxcIixcXG4gICAgbGluZW46IFxcXCJmYWYwZTZcXFwiLFxcbiAgICBtYWdlbnRhOiBcXFwiZjBmXFxcIixcXG4gICAgbWFyb29uOiBcXFwiODAwMDAwXFxcIixcXG4gICAgbWVkaXVtYXF1YW1hcmluZTogXFxcIjY2Y2RhYVxcXCIsXFxuICAgIG1lZGl1bWJsdWU6IFxcXCIwMDAwY2RcXFwiLFxcbiAgICBtZWRpdW1vcmNoaWQ6IFxcXCJiYTU1ZDNcXFwiLFxcbiAgICBtZWRpdW1wdXJwbGU6IFxcXCI5MzcwZGJcXFwiLFxcbiAgICBtZWRpdW1zZWFncmVlbjogXFxcIjNjYjM3MVxcXCIsXFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogXFxcIjdiNjhlZVxcXCIsXFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBcXFwiMDBmYTlhXFxcIixcXG4gICAgbWVkaXVtdHVycXVvaXNlOiBcXFwiNDhkMWNjXFxcIixcXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBcXFwiYzcxNTg1XFxcIixcXG4gICAgbWlkbmlnaHRibHVlOiBcXFwiMTkxOTcwXFxcIixcXG4gICAgbWludGNyZWFtOiBcXFwiZjVmZmZhXFxcIixcXG4gICAgbWlzdHlyb3NlOiBcXFwiZmZlNGUxXFxcIixcXG4gICAgbW9jY2FzaW46IFxcXCJmZmU0YjVcXFwiLFxcbiAgICBuYXZham93aGl0ZTogXFxcImZmZGVhZFxcXCIsXFxuICAgIG5hdnk6IFxcXCIwMDAwODBcXFwiLFxcbiAgICBvbGRsYWNlOiBcXFwiZmRmNWU2XFxcIixcXG4gICAgb2xpdmU6IFxcXCI4MDgwMDBcXFwiLFxcbiAgICBvbGl2ZWRyYWI6IFxcXCI2YjhlMjNcXFwiLFxcbiAgICBvcmFuZ2U6IFxcXCJmZmE1MDBcXFwiLFxcbiAgICBvcmFuZ2VyZWQ6IFxcXCJmZjQ1MDBcXFwiLFxcbiAgICBvcmNoaWQ6IFxcXCJkYTcwZDZcXFwiLFxcbiAgICBwYWxlZ29sZGVucm9kOiBcXFwiZWVlOGFhXFxcIixcXG4gICAgcGFsZWdyZWVuOiBcXFwiOThmYjk4XFxcIixcXG4gICAgcGFsZXR1cnF1b2lzZTogXFxcImFmZWVlZVxcXCIsXFxuICAgIHBhbGV2aW9sZXRyZWQ6IFxcXCJkYjcwOTNcXFwiLFxcbiAgICBwYXBheWF3aGlwOiBcXFwiZmZlZmQ1XFxcIixcXG4gICAgcGVhY2hwdWZmOiBcXFwiZmZkYWI5XFxcIixcXG4gICAgcGVydTogXFxcImNkODUzZlxcXCIsXFxuICAgIHBpbms6IFxcXCJmZmMwY2JcXFwiLFxcbiAgICBwbHVtOiBcXFwiZGRhMGRkXFxcIixcXG4gICAgcG93ZGVyYmx1ZTogXFxcImIwZTBlNlxcXCIsXFxuICAgIHB1cnBsZTogXFxcIjgwMDA4MFxcXCIsXFxuICAgIHJlYmVjY2FwdXJwbGU6IFxcXCI2NjMzOTlcXFwiLFxcbiAgICByZWQ6IFxcXCJmMDBcXFwiLFxcbiAgICByb3N5YnJvd246IFxcXCJiYzhmOGZcXFwiLFxcbiAgICByb3lhbGJsdWU6IFxcXCI0MTY5ZTFcXFwiLFxcbiAgICBzYWRkbGVicm93bjogXFxcIjhiNDUxM1xcXCIsXFxuICAgIHNhbG1vbjogXFxcImZhODA3MlxcXCIsXFxuICAgIHNhbmR5YnJvd246IFxcXCJmNGE0NjBcXFwiLFxcbiAgICBzZWFncmVlbjogXFxcIjJlOGI1N1xcXCIsXFxuICAgIHNlYXNoZWxsOiBcXFwiZmZmNWVlXFxcIixcXG4gICAgc2llbm5hOiBcXFwiYTA1MjJkXFxcIixcXG4gICAgc2lsdmVyOiBcXFwiYzBjMGMwXFxcIixcXG4gICAgc2t5Ymx1ZTogXFxcIjg3Y2VlYlxcXCIsXFxuICAgIHNsYXRlYmx1ZTogXFxcIjZhNWFjZFxcXCIsXFxuICAgIHNsYXRlZ3JheTogXFxcIjcwODA5MFxcXCIsXFxuICAgIHNsYXRlZ3JleTogXFxcIjcwODA5MFxcXCIsXFxuICAgIHNub3c6IFxcXCJmZmZhZmFcXFwiLFxcbiAgICBzcHJpbmdncmVlbjogXFxcIjAwZmY3ZlxcXCIsXFxuICAgIHN0ZWVsYmx1ZTogXFxcIjQ2ODJiNFxcXCIsXFxuICAgIHRhbjogXFxcImQyYjQ4Y1xcXCIsXFxuICAgIHRlYWw6IFxcXCIwMDgwODBcXFwiLFxcbiAgICB0aGlzdGxlOiBcXFwiZDhiZmQ4XFxcIixcXG4gICAgdG9tYXRvOiBcXFwiZmY2MzQ3XFxcIixcXG4gICAgdHVycXVvaXNlOiBcXFwiNDBlMGQwXFxcIixcXG4gICAgdmlvbGV0OiBcXFwiZWU4MmVlXFxcIixcXG4gICAgd2hlYXQ6IFxcXCJmNWRlYjNcXFwiLFxcbiAgICB3aGl0ZTogXFxcImZmZlxcXCIsXFxuICAgIHdoaXRlc21va2U6IFxcXCJmNWY1ZjVcXFwiLFxcbiAgICB5ZWxsb3c6IFxcXCJmZjBcXFwiLFxcbiAgICB5ZWxsb3dncmVlbjogXFxcIjlhY2QzMlxcXCJcXG59O1xcblxcbi8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBoZXhOYW1lc1toZXhdXFxudmFyIGhleE5hbWVzID0gdGlueWNvbG9yLmhleE5hbWVzID0gZmxpcChuYW1lcyk7XFxuXFxuLy8gVXRpbGl0aWVzXFxuLy8gLS0tLS0tLS0tXFxuXFxuLy8geyAnbmFtZTEnOiAndmFsMScgfSBiZWNvbWVzIHsgJ3ZhbDEnOiAnbmFtZTEnIH1cXG5mdW5jdGlvbiBmbGlwKG8pIHtcXG4gICAgdmFyIGZsaXBwZWQgPSB7IH07XFxuICAgIGZvciAodmFyIGkgaW4gbykge1xcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZmxpcHBlZDtcXG59XFxuXFxuLy8gUmV0dXJuIGEgdmFsaWQgYWxwaGEgdmFsdWUgWzAsMV0gd2l0aCBhbGwgaW52YWxpZCB2YWx1ZXMgYmVpbmcgc2V0IHRvIDFcXG5mdW5jdGlvbiBib3VuZEFscGhhKGEpIHtcXG4gICAgYSA9IHBhcnNlRmxvYXQoYSk7XFxuXFxuICAgIGlmIChpc05hTihhKSB8fCBhIDwgMCB8fCBhID4gMSkge1xcbiAgICAgICAgYSA9IDE7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGE7XFxufVxcblxcbi8vIFRha2UgaW5wdXQgZnJvbSBbMCwgbl0gYW5kIHJldHVybiBpdCBhcyBbMCwgMV1cXG5mdW5jdGlvbiBib3VuZDAxKG4sIG1heCkge1xcbiAgICBpZiAoaXNPbmVQb2ludFplcm8obikpIHsgbiA9IFxcXCIxMDAlXFxcIjsgfVxcblxcbiAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBpc1BlcmNlbnRhZ2Uobik7XFxuICAgIG4gPSBtYXRoTWluKG1heCwgbWF0aE1heCgwLCBwYXJzZUZsb2F0KG4pKSk7XFxuXFxuICAgIC8vIEF1dG9tYXRpY2FsbHkgY29udmVydCBwZXJjZW50YWdlIGludG8gbnVtYmVyXFxuICAgIGlmIChwcm9jZXNzUGVyY2VudCkge1xcbiAgICAgICAgbiA9IHBhcnNlSW50KG4gKiBtYXgsIDEwKSAvIDEwMDtcXG4gICAgfVxcblxcbiAgICAvLyBIYW5kbGUgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzXFxuICAgIGlmICgoTWF0aC5hYnMobiAtIG1heCkgPCAwLjAwMDAwMSkpIHtcXG4gICAgICAgIHJldHVybiAxO1xcbiAgICB9XFxuXFxuICAgIC8vIENvbnZlcnQgaW50byBbMCwgMV0gcmFuZ2UgaWYgaXQgaXNuJ3QgYWxyZWFkeVxcbiAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xcbn1cXG5cXG4vLyBGb3JjZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcXG5mdW5jdGlvbiBjbGFtcDAxKHZhbCkge1xcbiAgICByZXR1cm4gbWF0aE1pbigxLCBtYXRoTWF4KDAsIHZhbCkpO1xcbn1cXG5cXG4vLyBQYXJzZSBhIGJhc2UtMTYgaGV4IHZhbHVlIGludG8gYSBiYXNlLTEwIGludGVnZXJcXG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XFxuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDE2KTtcXG59XFxuXFxuLy8gTmVlZCB0byBoYW5kbGUgMS4wIGFzIDEwMCUsIHNpbmNlIG9uY2UgaXQgaXMgYSBudW1iZXIsIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBpdCBhbmQgMVxcbi8vIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0MjIwNzIvamF2YXNjcmlwdC1ob3ctdG8tZGV0ZWN0LW51bWJlci1hcy1hLWRlY2ltYWwtaW5jbHVkaW5nLTEtMD5cXG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XFxuICAgIHJldHVybiB0eXBlb2YgbiA9PSBcXFwic3RyaW5nXFxcIiAmJiBuLmluZGV4T2YoJy4nKSAhPSAtMSAmJiBwYXJzZUZsb2F0KG4pID09PSAxO1xcbn1cXG5cXG4vLyBDaGVjayB0byBzZWUgaWYgc3RyaW5nIHBhc3NlZCBpbiBpcyBhIHBlcmNlbnRhZ2VcXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2Uobikge1xcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09IFxcXCJzdHJpbmdcXFwiICYmIG4uaW5kZXhPZignJScpICE9IC0xO1xcbn1cXG5cXG4vLyBGb3JjZSBhIGhleCB2YWx1ZSB0byBoYXZlIDIgY2hhcmFjdGVyc1xcbmZ1bmN0aW9uIHBhZDIoYykge1xcbiAgICByZXR1cm4gYy5sZW5ndGggPT0gMSA/ICcwJyArIGMgOiAnJyArIGM7XFxufVxcblxcbi8vIFJlcGxhY2UgYSBkZWNpbWFsIHdpdGggaXQncyBwZXJjZW50YWdlIHZhbHVlXFxuZnVuY3Rpb24gY29udmVydFRvUGVyY2VudGFnZShuKSB7XFxuICAgIGlmIChuIDw9IDEpIHtcXG4gICAgICAgIG4gPSAobiAqIDEwMCkgKyBcXFwiJVxcXCI7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG47XFxufVxcblxcbi8vIENvbnZlcnRzIGEgZGVjaW1hbCB0byBhIGhleCB2YWx1ZVxcbmZ1bmN0aW9uIGNvbnZlcnREZWNpbWFsVG9IZXgoZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGQpICogMjU1KS50b1N0cmluZygxNik7XFxufVxcbi8vIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIGEgZGVjaW1hbFxcbmZ1bmN0aW9uIGNvbnZlcnRIZXhUb0RlY2ltYWwoaCkge1xcbiAgICByZXR1cm4gKHBhcnNlSW50RnJvbUhleChoKSAvIDI1NSk7XFxufVxcblxcbnZhciBtYXRjaGVycyA9IChmdW5jdGlvbigpIHtcXG5cXG4gICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNpbnRlZ2Vycz5cXG4gICAgdmFyIENTU19JTlRFR0VSID0gXFxcIlstXFxcXFxcXFwrXT9cXFxcXFxcXGQrJT9cXFwiO1xcblxcbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI251bWJlci12YWx1ZT5cXG4gICAgdmFyIENTU19OVU1CRVIgPSBcXFwiWy1cXFxcXFxcXCtdP1xcXFxcXFxcZCpcXFxcXFxcXC5cXFxcXFxcXGQrJT9cXFwiO1xcblxcbiAgICAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gIERvbid0IGNhcHR1cmUgdGhlIGVpdGhlci9vciwganVzdCB0aGUgZW50aXJlIG91dGNvbWUuXFxuICAgIHZhciBDU1NfVU5JVCA9IFxcXCIoPzpcXFwiICsgQ1NTX05VTUJFUiArIFxcXCIpfCg/OlxcXCIgKyBDU1NfSU5URUdFUiArIFxcXCIpXFxcIjtcXG5cXG4gICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxcbiAgICAvLyBQYXJlbnRoZXNlcyBhbmQgY29tbWFzIGFyZSBvcHRpb25hbCwgYnV0IG5vdCByZXF1aXJlZC5cXG4gICAgLy8gV2hpdGVzcGFjZSBjYW4gdGFrZSB0aGUgcGxhY2Ugb2YgY29tbWFzIG9yIG9wZW5pbmcgcGFyZW5cXG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXFxcIltcXFxcXFxcXHN8XFxcXFxcXFwoXSsoXFxcIiArIENTU19VTklUICsgXFxcIilbLHxcXFxcXFxcXHNdKyhcXFwiICsgQ1NTX1VOSVQgKyBcXFwiKVssfFxcXFxcXFxcc10rKFxcXCIgKyBDU1NfVU5JVCArIFxcXCIpXFxcXFxcXFxzKlxcXFxcXFxcKT9cXFwiO1xcbiAgICB2YXIgUEVSTUlTU0lWRV9NQVRDSDQgPSBcXFwiW1xcXFxcXFxcc3xcXFxcXFxcXChdKyhcXFwiICsgQ1NTX1VOSVQgKyBcXFwiKVssfFxcXFxcXFxcc10rKFxcXCIgKyBDU1NfVU5JVCArIFxcXCIpWyx8XFxcXFxcXFxzXSsoXFxcIiArIENTU19VTklUICsgXFxcIilbLHxcXFxcXFxcXHNdKyhcXFwiICsgQ1NTX1VOSVQgKyBcXFwiKVxcXFxcXFxccypcXFxcXFxcXCk/XFxcIjtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIENTU19VTklUOiBuZXcgUmVnRXhwKENTU19VTklUKSxcXG4gICAgICAgIHJnYjogbmV3IFJlZ0V4cChcXFwicmdiXFxcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcXG4gICAgICAgIHJnYmE6IG5ldyBSZWdFeHAoXFxcInJnYmFcXFwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxcbiAgICAgICAgaHNsOiBuZXcgUmVnRXhwKFxcXCJoc2xcXFwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxcbiAgICAgICAgaHNsYTogbmV3IFJlZ0V4cChcXFwiaHNsYVxcXCIgKyBQRVJNSVNTSVZFX01BVENINCksXFxuICAgICAgICBoc3Y6IG5ldyBSZWdFeHAoXFxcImhzdlxcXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXFxuICAgICAgICBoc3ZhOiBuZXcgUmVnRXhwKFxcXCJoc3ZhXFxcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcXG4gICAgICAgIGhleDM6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcXG4gICAgICAgIGhleDY6IC9eIz8oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkLyxcXG4gICAgICAgIGhleDQ6IC9eIz8oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC8sXFxuICAgICAgICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXFxuICAgIH07XFxufSkoKTtcXG5cXG4vLyBpc1ZhbGlkQ1NTVW5pdFxcbi8vIFRha2UgaW4gYSBzaW5nbGUgc3RyaW5nIC8gbnVtYmVyIGFuZCBjaGVjayB0byBzZWUgaWYgaXQgbG9va3MgbGlrZSBhIENTUyB1bml0XFxuLy8gKHNlZSBtYXRjaGVycyBhYm92ZSBmb3IgZGVmaW5pdGlvbikuXFxuZnVuY3Rpb24gaXNWYWxpZENTU1VuaXQoY29sb3IpIHtcXG4gICAgcmV0dXJuICEhbWF0Y2hlcnMuQ1NTX1VOSVQuZXhlYyhjb2xvcik7XFxufVxcblxcbi8vIHN0cmluZ0lucHV0VG9PYmplY3RcXG4vLyBQZXJtaXNzaXZlIHN0cmluZyBwYXJzaW5nLiAgVGFrZSBpbiBhIG51bWJlciBvZiBmb3JtYXRzLCBhbmQgb3V0cHV0IGFuIG9iamVjdFxcbi8vIGJhc2VkIG9uIGRldGVjdGVkIGZvcm1hdC4gIFJldHVybnMgeyByLCBnLCBiIH0gb3IgeyBoLCBzLCBsIH0gb3IgeyBoLCBzLCB2fVxcbmZ1bmN0aW9uIHN0cmluZ0lucHV0VG9PYmplY3QoY29sb3IpIHtcXG5cXG4gICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKHRyaW1MZWZ0LCAnJykucmVwbGFjZSh0cmltUmlnaHQsICcnKS50b0xvd2VyQ2FzZSgpO1xcbiAgICB2YXIgbmFtZWQgPSBmYWxzZTtcXG4gICAgaWYgKG5hbWVzW2NvbG9yXSkge1xcbiAgICAgICAgY29sb3IgPSBuYW1lc1tjb2xvcl07XFxuICAgICAgICBuYW1lZCA9IHRydWU7XFxuICAgIH1cXG4gICAgZWxzZSBpZiAoY29sb3IgPT0gJ3RyYW5zcGFyZW50Jykge1xcbiAgICAgICAgcmV0dXJuIHsgcjogMCwgZzogMCwgYjogMCwgYTogMCwgZm9ybWF0OiBcXFwibmFtZVxcXCIgfTtcXG4gICAgfVxcblxcbiAgICAvLyBUcnkgdG8gbWF0Y2ggc3RyaW5nIGlucHV0IHVzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXFxuICAgIC8vIEtlZXAgbW9zdCBvZiB0aGUgbnVtYmVyIGJvdW5kaW5nIG91dCBvZiB0aGlzIGZ1bmN0aW9uIC0gZG9uJ3Qgd29ycnkgYWJvdXQgWzAsMV0gb3IgWzAsMTAwXSBvciBbMCwzNjBdXFxuICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cXG4gICAgLy8gVGhpcyB3YXkgdGhlIHJlc3VsdCB3aWxsIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHRpbnljb2xvciBpcyBpbml0aWFsaXplZCB3aXRoIHN0cmluZyBvciBvYmplY3QuXFxuICAgIHZhciBtYXRjaDtcXG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10gfTtcXG4gICAgfVxcbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XFxuICAgIH1cXG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10gfTtcXG4gICAgfVxcbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XFxuICAgIH1cXG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10gfTtcXG4gICAgfVxcbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2YS5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XFxuICAgIH1cXG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0pLFxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcXFwibmFtZVxcXCIgOiBcXFwiaGV4OFxcXCJcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcXFwibmFtZVxcXCIgOiBcXFwiaGV4XFxcIlxcbiAgICAgICAgfTtcXG4gICAgfVxcbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdICsgJycgKyBtYXRjaFszXSksXFxuICAgICAgICAgICAgYTogY29udmVydEhleFRvRGVjaW1hbChtYXRjaFs0XSArICcnICsgbWF0Y2hbNF0pLFxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcXFwibmFtZVxcXCIgOiBcXFwiaGV4OFxcXCJcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSArICcnICsgbWF0Y2hbMl0pLFxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcXFwibmFtZVxcXCIgOiBcXFwiaGV4XFxcIlxcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIHZhbGlkYXRlV0NBRzJQYXJtcyhwYXJtcykge1xcbiAgICAvLyByZXR1cm4gdmFsaWQgV0NBRzIgcGFybXMgZm9yIGlzUmVhZGFibGUuXFxuICAgIC8vIElmIGlucHV0IHBhcm1zIGFyZSBpbnZhbGlkLCByZXR1cm4ge1xcXCJsZXZlbFxcXCI6XFxcIkFBXFxcIiwgXFxcInNpemVcXFwiOlxcXCJzbWFsbFxcXCJ9XFxuICAgIHZhciBsZXZlbCwgc2l6ZTtcXG4gICAgcGFybXMgPSBwYXJtcyB8fCB7XFxcImxldmVsXFxcIjpcXFwiQUFcXFwiLCBcXFwic2l6ZVxcXCI6XFxcInNtYWxsXFxcIn07XFxuICAgIGxldmVsID0gKHBhcm1zLmxldmVsIHx8IFxcXCJBQVxcXCIpLnRvVXBwZXJDYXNlKCk7XFxuICAgIHNpemUgPSAocGFybXMuc2l6ZSB8fCBcXFwic21hbGxcXFwiKS50b0xvd2VyQ2FzZSgpO1xcbiAgICBpZiAobGV2ZWwgIT09IFxcXCJBQVxcXCIgJiYgbGV2ZWwgIT09IFxcXCJBQUFcXFwiKSB7XFxuICAgICAgICBsZXZlbCA9IFxcXCJBQVxcXCI7XFxuICAgIH1cXG4gICAgaWYgKHNpemUgIT09IFxcXCJzbWFsbFxcXCIgJiYgc2l6ZSAhPT0gXFxcImxhcmdlXFxcIikge1xcbiAgICAgICAgc2l6ZSA9IFxcXCJzbWFsbFxcXCI7XFxuICAgIH1cXG4gICAgcmV0dXJuIHtcXFwibGV2ZWxcXFwiOmxldmVsLCBcXFwic2l6ZVxcXCI6c2l6ZX07XFxufVxcblxcbnRoaXMudGlueWNvbG9yID0gdGlueWNvbG9yO1xcblxcbn0pKClgO1xcbn1cXG4vLyBJdCBpcyBoYWNreSB3YXkgdG8gbWFrZSB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY29tcGlsZWQgcHJlZmVyZW50aWFsbHkgYnkgbGVzc1xcbi8vIHJlc29sdmUgZXJyb3I6IGBSZWZlcmVuY2VFcnJvcjogY29sb3JQYWxldHRlIGlzIG5vdCBkZWZpbmVkYFxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnQtZGVzaWduL2FudC1tb3Rpb24vaXNzdWVzLzQ0XFxuLnRpbnlDb2xvck1peGluKCk7XFxuXCIsXCJAaW1wb3J0ICcuLi90aGVtZXMvaW5kZXgnO1xcblxcbi5yZXNldC1jb21wb25lbnQoKSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGNvbG9yOiBAdGV4dC1jb2xvcjtcXG4gIGZvbnQtc2l6ZTogQGZvbnQtc2l6ZS1iYXNlO1xcbiAgZm9udC12YXJpYW50OiBAZm9udC12YXJpYW50LWJhc2U7XFxuICBsaW5lLWhlaWdodDogQGxpbmUtaGVpZ2h0LWJhc2U7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBAZm9udC1mZWF0dXJlLXNldHRpbmdzLWJhc2U7XFxufVxcblwiLFwiQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogQHNjcmVlbi1tZCkge1xcbiAgLkB7YmFja3RvcC1wcmVmaXgtY2xzfSB7XFxuICAgIHJpZ2h0OiA2MHB4O1xcbiAgfVxcbn1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiBAc2NyZWVuLXhzKSB7XFxuICAuQHtiYWNrdG9wLXByZWZpeC1jbHN9IHtcXG4gICAgcmlnaHQ6IDIwcHg7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0udXNlWzJdIS4vaW5kZXgubGVzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJzb3VyY2VSb290IjoiIn0=